# 에이전트 작업 지시서 #6: 함수 레퍼런스 가이드 작성

## 에이전트 역할
당신은 LDM-EKI 시스템의 모든 함수를 체계적으로 분류하고 문서화하는 API 문서 전문가입니다.

## 작업 목표
"함수_레퍼런스_가이드.txt" 파일을 작성하여 전체 코드베이스의 모든 함수를 완벽하게 카탈로그화하고 각 함수의 기능, 파라미터, 사용법을 상세히 문서화합니다.

## ⚠️ 중요: 완전성 원칙
- **모든 함수를 빠짐없이 문서화**해야 합니다
- **모든 .cu, .cuh, .py 파일을 스캔**해야 합니다
- **Private 함수도 포함**해야 합니다
- **Deprecated 함수도 표시**해야 합니다

## 함수 추출 및 분류 전략

### 1단계: 모든 소스 파일 스캔
```bash
# C++ 함수 추출
find src -name "*.cu" -o -name "*.cuh" | while read f; do
    echo "=== $f ==="
    # 함수 시그니처 추출
    grep -E "^[a-zA-Z_].+\(" "$f" | grep -v "//"
    # 클래스 메서드 추출
    grep -E "^\s+(void|bool|int|float|double|static).+\(" "$f" | grep -v "//"
done > /tmp/cpp_functions.txt

# Python 함수 추출
find src util -name "*.py" | while read f; do
    echo "=== $f ==="
    grep -n "^def " "$f"
    grep -n "^    def " "$f"  # 클래스 메서드
done > /tmp/python_functions.txt

# CUDA 커널 추출
find src -name "*.cu" | while read f; do
    echo "=== $f ==="
    grep -n "__global__" "$f"
done > /tmp/cuda_kernels.txt
```

### 2단계: 함수 분류 체계

#### C++ 함수 분류
1. **초기화 함수** (initialize*, init*, load*)
2. **시뮬레이션 함수** (run*, simulate*, step*)
3. **데이터 처리 함수** (process*, compute*, calculate*)
4. **I/O 함수** (read*, write*, save*, load*)
5. **IPC 함수** (send*, receive*, wait*, check*)
6. **메모리 관리** (allocate*, free*, cleanup*)
7. **유틸리티 함수** (get*, set*, validate*, format*)
8. **디버깅 함수** (log*, print*, dump*)

#### Python 함수 분류
1. **EKI 알고리즘** (EnKF*, Adaptive*, Localiz*, Regulariz*)
2. **모델 연결** (Model.*, receive_*, send_*)
3. **시각화** (plot*, visualize*, create_*, draw_*)
4. **후처리** (analyze*, extract*, process*)
5. **유틸리티** (parse*, load_, save_*, clean*)

#### CUDA 커널 분류
1. **입자 업데이트** (updateParticles*, advectParticles*)
2. **관측 수집** (collectObservations*, gatherReceptor*)
3. **그리드 덤프** (dumpToGrid*, accumulateGrid*)
4. **물리 모델** (applyTurbulence*, applyDeposition*, decayNuclides*)

## 필수 분석 파일 목록 (완전 체크리스트)

### C++ 코어 시스템 (src/core/)
- [ ] ldm.cu - 모든 public/private 메서드
- [ ] ldm.cuh - 클래스 선언
- [ ] device_storage.cu
- [ ] params.hpp

### C++ 초기화 (src/init/)
- [ ] ldm_init_config.cu - 모든 파서 함수
- [ ] ldm_init_particles.cu - 입자 초기화 함수

### C++ 시뮬레이션 (src/simulation/)
- [ ] ldm_func_simulation.cu - 시뮬레이션 루프 함수
- [ ] ldm_func_particle.cu - 입자 관련 함수
- [ ] ldm_func_output.cu - 출력 함수

### C++ 커널 (src/kernels/)
- [ ] kernels/particle/ldm_kernels_particle.cu
- [ ] kernels/particle/ldm_kernels_particle_ens.cu
- [ ] kernels/device/ldm_kernels_device.cu
- [ ] kernels/eki/ldm_kernels_eki.cu
- [ ] kernels/dump/ldm_kernels_dump.cu
- [ ] kernels/dump/ldm_kernels_dump_ens.cu
- [ ] kernels/cram/ldm_kernels_cram.cuh

### C++ IPC (src/ipc/)
- [ ] ldm_eki_writer.cu - 모든 write* 함수
- [ ] ldm_eki_reader.cu - 모든 read*, wait* 함수

### C++ 물리 (src/physics/)
- [ ] ldm_cram2.cu - CRAM 관련 함수
- [ ] ldm_nuclides.cu - 핵종 관련 함수

### C++ 시각화 (src/visualization/)
- [ ] ldm_plot_vtk.cu - VTK 출력 함수
- [ ] ldm_plot_utils.cu - 플롯 유틸리티

### C++ 디버그 (src/debug/)
- [ ] kernel_error_collector.cu - 에러 수집 함수
- [ ] memory_doctor.cu - 메모리 디버깅 함수

### C++ 데이터/메테오 (src/data/meteo/)
- [ ] ldm_mdata_loading.cu - 기상 데이터 로딩
- [ ] ldm_mdata_cache.cu - 캐싱 함수

### Python EKI (src/eki/)
- [ ] RunEstimator.py - 메인 실행 함수
- [ ] Optimizer_EKI_np.py - 모든 EKI 알고리즘 (Inverse 클래스)
- [ ] Model_Connection_np_Ensemble.py - Model 클래스 모든 메서드
- [ ] eki_ipc_reader.py - 모든 receive* 함수
- [ ] eki_ipc_writer.py - 모든 write* 함수
- [ ] eki_shm_config.py - 설정 로딩 함수
- [ ] eki_debug_logger.py - 로깅 클래스
- [ ] memory_doctor.py - MemoryDoctor 클래스

### Python 유틸리티 (util/)
- [ ] cleanup.py - 모든 clean* 함수
- [ ] compare_all_receptors.py - 모든 plot*, load* 함수
- [ ] detailed_postprocess.py - 모든 extract*, generate* 함수
- [ ] visualize_vtk.py - VTKVisualizer 클래스 모든 메서드

## 보고서 작성 구조

### 섹션 1: 개요 및 인덱스 (약 300줄)

#### 1.1 문서 사용법
- 함수 검색 방법
- 카테고리별 탐색
- 알파벳순 인덱스

#### 1.2 전체 통계
- 총 C++ 함수 개수
- 총 Python 함수 개수
- 총 CUDA 커널 개수
- 파일별 함수 개수

#### 1.3 명명 규칙
- 함수명 컨벤션
- 접두사 의미 (init*, run*, get*, set* 등)
- Public vs Private 구분

### 섹션 2: C++ 함수 레퍼런스 (약 2,500줄)

#### 형식 (각 함수별):
```
함수명: LDM::initializeParticlesEKI
파일: src/init/ldm_init_particles.cu:245
카테고리: 초기화
가시성: Public

시그니처:
void LDM::initializeParticlesEKI(int source_index, double emission_rate)

파라미터:
- source_index (int): 방출원 인덱스 (0부터 시작)
- emission_rate (double): 방출률 [Bq/s]

반환값:
- void

기능:
EKI 실행을 위한 입자를 초기화합니다. 참값 시뮬레이션(prior run)에서
사용되며, 각 방출원에서 지정된 방출률로 입자를 생성합니다.

알고리즘:
1. 총 입자 수를 방출원 개수로 나눔
2. 각 입자에 위치, 질량, 핵종 정보 할당
3. 시간 인덱스 설정
4. GPU 메모리로 복사

사용 예제:
// 방출원 0번에서 1e10 Bq/s로 입자 초기화
ldm.initializeParticlesEKI(0, 1e10);

호출 위치:
- src/main_eki.cu:156
- src/simulation/ldm_func_simulation.cu:89

관련 함수:
- initializeParticlesEKI_AllEnsembles() (앙상블 버전)
- allocateParticleMemory()

버전 히스토리:
- v1.0: 초기 구현
- v1.0-beta: 앙상블 지원 추가

노트:
- 이 함수는 CPU에서 실행되며, 데이터를 GPU로 전송합니다
- 메모리는 사전에 allocateParticleMemory()로 할당되어 있어야 합니다
```

#### 하위 카테고리:

##### 2.1 LDM 클래스 메인 메서드 (약 400줄)
- 생성자/소멸자
- 초기화 함수 (10+ 함수)
- 시뮬레이션 실행 함수 (5+ 함수)
- 설정 로딩 함수 (7+ 함수)

##### 2.2 입자 관련 함수 (약 300줄)
- 입자 초기화
- 입자 업데이트
- 입자 메모리 관리

##### 2.3 기상 데이터 함수 (약 250줄)
- 데이터 로딩
- 캐싱
- 보간

##### 2.4 IPC 함수 (약 300줄)
- Writer 클래스 메서드
- Reader 클래스 메서드
- 동기화 함수

##### 2.5 출력 함수 (약 200줄)
- VTK 출력
- 로그 출력
- 디버그 출력

##### 2.6 유틸리티 함수 (약 200줄)
- 검증 함수
- 변환 함수
- 헬퍼 함수

##### 2.7 물리 모델 함수 (약 150줄)
- CRAM 함수
- 핵종 관리
- 침적 모델

##### 2.8 디버깅 함수 (약 200줄)
- 에러 수집
- 메모리 디버깅

### 섹션 3: CUDA 커널 레퍼런스 (약 800줄)

#### 형식:
```
커널명: updateParticles_kernel
파일: src/kernels/particle/ldm_kernels_particle.cu:89
카테고리: 입자 업데이트

시그니처:
__global__ void updateParticles_kernel(
    Particle* d_part,
    int num_particles,
    KernelScalars scalars,
    float dt
)

파라미터:
- d_part: 입자 배열 (GPU 메모리)
- num_particles: 입자 개수
- scalars: 커널 파라미터 구조체
- dt: 시간 스텝 [초]

그리드/블록 구성:
- Grid: (num_particles + 255) / 256
- Block: 256

기능:
각 입자의 위치와 상태를 한 시간 스텝만큼 업데이트합니다.
난류 확산, 이류, 침적, 방사성 붕괴를 모두 고려합니다.

알고리즘:
1. 스레드 인덱스로 입자 선택
2. 기상 데이터 보간
3. 이류 계산 (바람)
4. 난류 확산 계산
5. 침적 계산
6. 방사성 붕괴 계산
7. 위치 업데이트

성능:
- 레지스터 사용량: 42개
- 공유 메모리: 0 bytes
- Occupancy: 75%

호출:
updateParticles_kernel<<<grid, block>>>(d_part, n, scalars, dt);
cudaDeviceSynchronize();
CHECK_KERNEL_ERROR();

관련 커널:
- updateParticles_ensemble_kernel (앙상블 버전)
- advectParticles_kernel (이류만)
```

#### 하위 카테고리:
##### 3.1 입자 커널 (약 300줄)
##### 3.2 관측 커널 (약 200줄)
##### 3.3 그리드 덤프 커널 (약 200줄)
##### 3.4 디바이스 함수 (약 100줄)

### 섹션 4: Python 함수 레퍼런스 (약 2,000줄)

#### 형식:
```
함수명: Inverse.EnKF
파일: src/eki/Optimizer_EKI_np.py:156
카테고리: EKI 알고리즘
클래스: Inverse

시그니처:
def EnKF(self, X, HX, y, R, tol=0):

파라미터:
- X (np.ndarray): 사전 앙상블 상태, shape (n_state, n_ensemble)
- HX (np.ndarray): 사전 관측값, shape (n_obs, n_ensemble)
- y (np.ndarray): 실제 관측값, shape (n_obs,)
- R (np.ndarray): 관측 오차 공분산, shape (n_obs, n_obs)
- tol (float, optional): 수렴 허용오차, 기본값 0

반환값:
- X_updated (np.ndarray): 사후 앙상블 상태, shape (n_state, n_ensemble)
- convergence (float): 수렴 메트릭

기능:
표준 앙상블 칼만 필터를 사용하여 앙상블 상태를 업데이트합니다.

수학적 공식:
K = P_f H^T (HP_f H^T + R)^{-1}
X_a = X_f + K(y - HX_f)

where:
- K: 칼만 이득
- P_f: 사전 공분산
- H: 관측 연산자 (Model.state_to_ob)

알고리즘:
1. 앙상블 평균 계산
2. 공분산 행렬 계산
3. 칼만 이득 계산
4. 혁신 벡터 계산 (y - mean(HX))
5. 상태 업데이트
6. 수렴 체크

사용 예제:
inverse = Inverse(num_states=24, num_ensemble=100)
X_updated, conv = inverse.EnKF(X, HX, y, R, tol=0.01)
print(f"Convergence: {conv}")

호출 위치:
- RunEstimator.py:178
- Optimizer_EKI_np.py:456 (Adaptive_EnKF 내부)

의존성:
- numpy.linalg (SVD, pinv)
- _ave_substracted() (내부 함수)
- _convergence() (내부 함수)

예외:
- LinAlgError: SVD 수렴 실패 시
- ValueError: 배열 크기 불일치 시

노트:
- 앙상블 크기가 상태 변수보다 작으면 ill-posed
- 큰 시스템에서는 메모리 부족 가능
- Localized 버전 사용 권장 (v1.0에서는 비활성화)

버전:
- v0.9: 초기 구현
- v1.0: rcond 파라미터 추가, 안정성 개선
```

#### 하위 카테고리:

##### 4.1 EKI 알고리즘 (약 600줄)
- Inverse 클래스 모든 메서드
- EnKF, Adaptive_EnKF, Regularized, EnRML 등

##### 4.2 모델 연결 (약 400줄)
- Model 클래스
- IPC 함수들
- 설정 로딩

##### 4.3 시각화 함수 (약 500줄)
- compare_all_receptors.py 모든 함수
- visualize_vtk.py VTKVisualizer 클래스
- 플롯 생성 함수

##### 4.4 후처리 함수 (약 300줄)
- detailed_postprocess.py 함수들
- 데이터 추출
- 통계 분석

##### 4.5 유틸리티 함수 (약 200줄)
- cleanup.py
- 헬퍼 함수들

### 섹션 5: 함수 호출 그래프 (약 500줄)

#### 5.1 메인 실행 흐름
```
main_eki.cu:main()
├─ LDM::LDM() (생성자)
├─ LDM::loadSimulationConfig()
│  ├─ parseSimulationConfig()
│  └─ validateSimulationConfig()
├─ LDM::loadPhysicsConfig()
├─ LDM::initializeDeviceMemory()
│  ├─ allocateParticleMemory()
│  ├─ allocateMeteoMemory()
│  └─ allocateGridMemory()
├─ LDM::preloadAllEKIMeteorologicalData()
│  └─ loadMeteorologicalDataParallel()
├─ system("python3 src/eki/RunEstimator.py")
│  └─ Python 프로세스 시작
├─ LDM::runSimulation_eki_init() (Prior)
│  ├─ initializeParticlesEKI()
│  ├─ runSimulationLoop()
│  │  └─ updateParticles_kernel<<<>>>()
│  └─ EKIWriter::writeObservations()
└─ LDM::runSimulation_eki_ensemble() (반복)
   ├─ EKIReader::waitForEnsembleData()
   ├─ initializeParticlesEKI_AllEnsembles()
   ├─ runSimulationLoop_ensemble()
   │  └─ updateParticles_ensemble_kernel<<<>>>()
   └─ EKIWriter::writeEnsembleObservations()
```

#### 5.2 Python EKI 흐름
```
RunEstimator.py:main()
├─ load_config_from_shared_memory()
├─ Model() (생성자)
│  └─ receive_gamma_dose_matrix_shm()
├─ Model.make_ensemble()
│  └─ _perturb()
├─ for iteration in range(max_iter):
│  ├─ write_ensemble_to_shm()
│  ├─ receive_ensemble_observations_shm()
│  ├─ Model.state_to_ob()
│  ├─ Inverse.EnKF() 또는
│  │  Inverse.Adaptive_EnKF() 또는
│  │  Inverse.REnKF()
│  └─ _convergence() 체크
└─ save_results()
```

#### 5.3 IPC 통신 흐름
```
C++ → Python (설정)
main_eki.cu → /dev/shm/ldm_eki_full_config → load_config_from_shared_memory()

C++ → Python (관측값)
writeObservations() → /dev/shm/ldm_eki_data → receive_gamma_dose_matrix_shm()

Python → C++ (앙상블 상태)
write_ensemble_to_shm() → /dev/shm/ldm_eki_ensemble_i → readEnsembleStates()

C++ → Python (앙상블 관측값)
writeEnsembleObservations() → /dev/shm/ldm_eki_ensemble_obs_i → receive_ensemble_observations_shm()
```

### 섹션 6: 함수 사용 패턴 (약 400줄)

#### 6.1 일반적인 사용 패턴
- 초기화 → 실행 → 정리
- 에러 체크 패턴
- 메모리 관리 패턴

#### 6.2 모범 사례
- 함수 호출 순서
- 에러 처리
- 리소스 관리

#### 6.3 피해야 할 안티패턴
- 메모리 누수
- 동기화 오류
- 타입 불일치

### 섹션 7: 함수별 성능 프로파일 (약 300줄)

#### 7.1 병목 함수
- 실행 시간 상위 10개 함수
- 메모리 사용량 상위 10개
- GPU 활용률

#### 7.2 최적화 가능 함수
- 병렬화 가능
- 캐싱 가능
- 불필요한 계산

### 섹션 8: Deprecated 및 실험 함수 (약 200줄)

#### 8.1 Deprecated 함수
- 이유
- 대체 함수
- 제거 예정 버전

#### 8.2 실험적 함수
- 안정성 경고
- 사용 제한

### 섹션 9: 알파벳순 인덱스 (약 500줄)

모든 함수를 알파벳순으로 정렬하여 빠른 검색 지원:

```
A
- _ave_substracted() → Python, Optimizer_EKI_np.py:345
- advectParticles_kernel() → CUDA, ldm_kernels_particle.cu:234
- allocateGridMemory() → C++, ldm.cu:456

B
- Boundary() → Python, Boundary.py:12 [Deprecated]

C
- calculateChecksum() → C++, memory_doctor.cu:89
- calculate_checksum() → Python, memory_doctor.py:67
- centralized_localizer() → Python, Optimizer_EKI_np.py:224
- checkDataReady() → C++, ldm_eki_reader.cu:178
- CHECK_KERNEL_ERROR() → Macro, kernel_error_collector.cuh:23
- clean_logs() → Python, cleanup.py:45
...
```

## 함수 추출 자동화 스크립트

보고서 작성 전 다음 스크립트를 실행하여 모든 함수 목록 생성:

```bash
#!/bin/bash
# extract_all_functions.sh

OUTPUT_DIR="/tmp/ldm_eki_functions"
mkdir -p $OUTPUT_DIR

# C++ 함수
echo "Extracting C++ functions..."
find src -name "*.cu" -o -name "*.cuh" | while read file; do
    base=$(basename "$file" | sed 's/\.[^.]*$//')
    grep -n "^\s*\(void\|bool\|int\|float\|double\|static\|inline\|__device__\|__host__\|__global__\)" "$file" \
        | grep "(" | grep -v "//" > "$OUTPUT_DIR/${base}_functions.txt"
done

# Python 함수
echo "Extracting Python functions..."
find src util -name "*.py" | while read file; do
    base=$(basename "$file" .py)
    grep -n "^\s*def " "$file" > "$OUTPUT_DIR/${base}_functions.txt"
done

# 통계
echo "=== Statistics ===" > "$OUTPUT_DIR/SUMMARY.txt"
echo "C++ files: $(find src -name '*.cu' -o -name '*.cuh' | wc -l)" >> "$OUTPUT_DIR/SUMMARY.txt"
echo "Python files: $(find src util -name '*.py' | wc -l)" >> "$OUTPUT_DIR/SUMMARY.txt"
echo "Total C++ functions: $(cat $OUTPUT_DIR/*_functions.txt 2>/dev/null | grep -v '\.py' | wc -l)" >> "$OUTPUT_DIR/SUMMARY.txt"
echo "Total Python functions: $(cat $OUTPUT_DIR/*_functions.txt 2>/dev/null | grep 'def ' | wc -l)" >> "$OUTPUT_DIR/SUMMARY.txt"

cat "$OUTPUT_DIR/SUMMARY.txt"
```

## 작성 시 주의사항

1. **완전성 검증**
   - 추출 스크립트 실행 결과와 대조
   - 누락된 함수 없는지 확인
   - Private 함수도 포함

2. **일관된 형식**
   - 모든 함수에 동일한 템플릿 적용
   - 섹션별 통일된 스타일
   - 들여쓰기 일관성

3. **실용적인 예제**
   - 각 함수마다 실제 사용 예제
   - 일반적인 사용 케이스
   - 에러 처리 포함

4. **상호 참조**
   - 관련 함수 링크
   - 호출 관계 명시
   - 의존성 표시

5. **검색 가능성**
   - 알파벳순 인덱스
   - 카테고리별 인덱스
   - 파일별 인덱스

## 최종 체크리스트

함수 문서화 완료 확인:
- [ ] 모든 C++ .cu 파일 분석 (30+ 파일)
- [ ] 모든 C++ .cuh 파일 분석 (30+ 파일)
- [ ] 모든 Python .py 파일 분석 (15+ 파일)
- [ ] 모든 CUDA 커널 문서화 (20+ 커널)
- [ ] 모든 LDM 클래스 메서드 (50+ 메서드)
- [ ] 모든 IPC 함수 (20+ 함수)
- [ ] 모든 EKI 알고리즘 (8+ 알고리즘)
- [ ] 모든 시각화 함수 (30+ 함수)
- [ ] 함수 호출 그래프 완성
- [ ] 알파벳순 인덱스 완성
- [ ] 예제 코드 모든 함수 포함

## 최종 산출물
- 파일명: `/home/jrpark/ldm-eki-release.v.beta/docs/함수_레퍼런스_가이드.txt`
- 예상 분량: 6,500줄 이상
- 언어: 한국어
- 형식: API 레퍼런스 가이드 (색인, 예제, 다이어그램 포함)

## 예상 함수 개수
- C++ 함수: 300+ 개
- Python 함수: 150+ 개
- CUDA 커널: 20+ 개
- **총: 470+ 함수**