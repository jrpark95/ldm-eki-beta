################################################################################
#
#  LDM-EKI 알고리즘 검증 보고서 (Part 2)
#  LOCALIZED 옵션 검증 및 물리적 타당성 분석
#
#  버전: v1.0
#  작성일: 2025-10-18
#  분량: 800줄 (Part 2/3)
#
################################################################################

목차:
  Part 1 (이전 문서):
    1. 개요 및 배경
    2. EKI 알고리즘 구현 상세

  Part 2 (본 문서):
    3. LOCALIZED 옵션 검증 (400줄)
    4. 물리적 타당성 검증 (400줄)

  Part 3 (다음 문서):
    5. 수렴 특성 분석
    6. 파라미터 튜닝 가이드
    7. 검증 결과 요약

################################################################################
#
#  3. LOCALIZED 옵션 검증
#
################################################################################

3.1 Covariance Localization의 이론적 배경
──────────────────────────────────────────────────────────────

3.1.1 가짜 상관관계(Spurious Correlation) 문제

**문제의 원인:**

앙상블 크기가 유한할 때, 샘플 공분산은 진짜 공분산과 다릅니다:

  P̂ = (1/(N_e-1)) Σ (x_i - x̄)(x_i - x̄)ᵀ  (sample covariance)
  P = E[(x - E[x])(x - E[x])ᵀ]             (true covariance)

  오차: ||P̂ - P||_F = O(1/√N_e)

**물리적 의미:**

제한된 앙상블로 인해 **실제로는 독립적인 변수들 사이에 허위 상관관계가
나타납니다**. 예:

  - 풍상(upwind) 수용체와 풍하(downwind) 수용체가 부적절하게 상관
  - 먼 시간 간격의 방출량이 비물리적으로 연결
  - 멀리 떨어진 그리드 셀 간에 가짜 패턴 형성

**대기확산 문제에서의 영향:**

LDM-EKI v1.0 파라미터:
  - 앙상블 크기: N_e = 100
  - 상태 차원: n = 24 (15분 간격, 6시간)
  - 관측 차원: m = 3456 (216시간 × 16수용체)

비율: N_e/n = 100/24 ≈ 4.2

이론적 권장:
  N_e ≥ 2n → 100 ≥ 48 ✓ 만족
  N_e ≥ 10n → 100 ≥ 240 ✗ 불만족 (이상적 조건)

따라서:
  - **기본 안정성은 확보** (2n 조건 만족)
  - **정밀 추정에는 부족** (10n 조건 미달)
  - **가짜 상관관계 발생 가능**


3.1.2 Covariance Localization의 원리

**핵심 아이디어:**

거리 기반 tapering function으로 원거리 상관관계를 감쇠:

  P̃ = ρ ⊙ P̂

  여기서:
    - ρ : localization matrix
    - ⊙ : Hadamard (element-wise) product
    - P̃ : localized covariance

**Gaspari-Cohn 함수 (원래 이론):**

5차 구분 다항식으로 정의:

  ρ(r, L) = {
    1 - 5(r/L)²/3 + 5(r/L)³/8,                        if 0 ≤ r ≤ L
    4 - 5r/L + 5(r/L)²/3 + 5(r/L)³/24 - 5(r/L)⁴/12,  if L < r ≤ 2L
    0,                                                 if r > 2L
  }

  여기서:
    - r : 변수 간 거리 (예: 위도-경도 거리)
    - L : localization radius (cutoff scale)

**특징:**
  - Compact support: r > 2L에서 정확히 0
  - C² 연속: 2차 미분까지 연속 (부드러움)
  - 최대값 1 at r=0: 근거리는 영향 없음
  - 점진적 감쇠: 급격한 변화 없음

**LDM-EKI의 간소화 구현:**

계산 효율을 위해 Gaussian approximation 사용:

  ρ(r, L) = exp(-r²/(2L²))

  장점:
    - 계산 간단 (exponential 1회)
    - 미분 가능 (모든 차수)
    - 전역 정의 (모든 r)
    - Gaspari-Cohn과 유사한 형태

  단점:
    - Compact support 없음 (r→∞에서 0에 접근)
    - 매우 먼 거리에서 미약한 상관 잔존

**LDM-EKI의 Separable Localization:**

고차원 행렬의 효율적 처리를 위해 분리 가능한 localization 사용:

  파일: src/eki/Optimizer_EKI_np.py, lines 327-359

  ```python
  def centralized_localizer(matrix, L):
      # 1D taper for each dimension
      taper1 = np.exp(-np.arange(matrix.shape[0])**2 / (2*L**2))  # (m,)
      taper2 = np.exp(-np.arange(matrix.shape[1])**2 / (2*L**2))  # (n,)

      # Outer product creates (m, n) localization matrix
      Psi = taper1[:, np.newaxis] * taper2[np.newaxis, :]  # (m, n)

      # Element-wise multiplication
      localized_matrix = matrix * Psi

      return localized_matrix
  ```

  수학적 의미:
    ρ(i, j) = exp(-i²/(2L²)) × exp(-j²/(2L²))
            = exp(-(i² + j²)/(2L²))

  이는 2D Gaussian kernel의 separable form.

**적용 부분:**

Localization은 다음 공분산 행렬들에 적용:

  1. Cross-covariance: P_xy ∈ ℝⁿˣᵐ
     - 상태-관측 간 공분산
     - 차원: (24, 3456)
     - 목적: 먼 수용체의 영향 감쇠

  2. Observation covariance: P_yy ∈ ℝᵐˣᵐ
     - 관측-관측 간 공분산
     - 차원: (3456, 3456)
     - 목적: 먼 수용체 쌍의 가짜 상관 제거

**하지만 v1.0에서는 이 모든 구현이 비활성화됨.**


3.1.3 Localization Length Scale 선택

**물리적 고려사항:**

방사능 플륨(plume)의 공간 스케일:

  - 발원지-수용체 거리: ~10-50 km
  - 플륨 폭: ~1-10 km (기상 조건 의존)
  - 확산 시간 스케일: ~1-6 시간

**거리 단위:**

LDM-EKI는 위도/경도 좌표 사용:
  - 1° ≈ 111 km (위도)
  - 1° ≈ 88 km (경도, 북위 35°)

**Length scale 권장값:**

  L = 0.5° - 2.0° (약 50-200 km)

  - L = 0.5°: 강한 localization (50km 이상 무시)
  - L = 1.0°: 중간 localization (100km)
  - L = 2.0°: 약한 localization (200km)

**v1.0 설정 (참고용, 비활성화됨):**

  파일: input/eki.conf
  ```
  Localization_weighting_factor: 1.0
  ```

  이는 L = 1.0° = ~100km를 의미.


3.2 16가지 조합 테스트 설계
──────────────────────────────────────────────────────────────

3.2.1 테스트 조합 매트릭스

LDM-EKI는 4가지 고급 옵션을 지원:

  1. **ADAPTIVE**: 적응형 스텝 크기 조절 (On/Off)
  2. **LOCALIZED**: 공분산 국소화 (On/Off)
  3. **REGULARIZATION**: 비음수 제약 정규화 (On/Off)
  4. **PERTURB**: 반복마다 관측 섭동 (On/Off)

**총 조합 수:**
  2⁴ = 16 combinations

**테스트 매트릭스:**

  ID  | ADAPTIVE | LOCALIZED | REGULARIZATION | PERTURB | 설명
  ----|----------|-----------|----------------|---------|------------------
  01  | Off      | Off       | Off            | Off     | Baseline (Standard EnKF)
  02  | On       | Off       | Off            | Off     | Adaptive only
  03  | Off      | On        | Off            | Off     | Localized only
  04  | On       | On        | Off            | Off     | Adaptive + Localized
  05  | Off      | Off       | On             | Off     | Regularization only
  06  | On       | Off       | On             | Off     | Adaptive + Regularization
  07  | Off      | On        | On             | Off     | Localized + Regularization
  08  | On       | On        | On             | Off     | Adaptive + Localized + Regularization
  09  | Off      | Off       | Off            | On      | Perturb only
  10  | On       | Off       | Off            | On      | Adaptive + Perturb
  11  | Off      | On        | Off            | On      | Localized + Perturb
  12  | On       | On        | Off            | On      | Adaptive + Localized + Perturb
  13  | Off      | Off       | On             | On      | Regularization + Perturb
  14  | On       | Off       | On             | On      | Adaptive + Regularization + Perturb
  15  | Off      | On        | On             | On      | Localized + Regularization + Perturb
  16  | On       | On        | On             | On      | All options enabled


3.2.2 테스트 시나리오

**공통 설정:**

  - 시뮬레이션 시간: 6시간 (21600초)
  - 역산 시간 간격: 15분 (24 timesteps)
  - 앙상블 크기: 100
  - 수용체 개수: 16 (4×4 grid)
  - 관측 노이즈: 10% (EKI_NOISE_LEVEL=0.1)
  - 최대 반복: 10회

**참값 방출 패턴:**

  TRUE_EMISSION_SERIES (24 values):
    [5.0e+12, 5.0e+12, 4.0e+12, 3.0e+12, 2.5e+12, 2.0e+12,
     1.5e+12, 1.0e+12, 3.0e+12, 3.5e+12, 4.0e+12, 3.5e+12,
     3.0e+12, 2.5e+12, 2.0e+12, 1.5e+12, 1.0e+12, 8.0e+11,
     6.0e+11, 5.0e+11, 4.0e+11, 3.0e+11, 2.0e+11, 1.0e+11]

  특징:
    - 초기 고방출 (5 TBq)
    - 중간 저하 (1 TBq)
    - 재상승 (4 TBq)
    - 후반 감쇠 (0.1 TBq)
    - 복잡한 시간 구조 (EKI 도전 과제)

**사전 추정 (Prior):**

  PRIOR_EMISSION_CONSTANT: 1.0e+10 Bq

  즉, 참값보다 2 orders of magnitude 낮은 상수.


3.2.3 성공 기준

**기술적 기준 (Technical Validation):**

  1. **실행 완료:** 에러 없이 10회 반복 완료
  2. **수치 안정성:** NaN/Inf 발생 없음
  3. **메모리 안전:** 공유 메모리 읽기/쓰기 성공
  4. **수렴 여부:** 비용 함수 감소 확인

**물리적 기준 (Physical Validation):**

  1. **질량 보존:** 총 방출량이 물리적 범위 내
  2. **비음수성:** 모든 시간 방출량 ≥ 0
  3. **공간 일관성:** 수용체 관측과 플륨 위치 일치
  4. **시간 패턴:** 부드러운 시간 변화 (고주파 진동 없음)

**v1.0 테스트 결과:**
  - **기술적 기준:** 16/16 passed (100%)
  - **물리적 기준:** LOCALIZED 옵션 포함 조합 실패


3.3 발견된 버그 및 수정 (3개)
──────────────────────────────────────────────────────────────

3.3.1 Bug 1: Shape Broadcasting Error (LOCALIZED)

**증상:**

LOCALIZED=On으로 실행 시 다음 에러:

  ```
  ValueError: operands could not be broadcast together with shapes (24,72) (24,24)
  ```

**발생 위치:**

  파일: src/eki/Optimizer_EKI_np.py, line 369-370 (구 버전)

  ```python
  # 잘못된 코드 (수정 전)
  pxz = localizer_func(pxz, self.weighting_factor)
  pzz = localizer_func(pzz, self.weighting_factor)
  ```

**원인 분석:**

Separable localization 구현 오류:

  구버전 코드 (잘못됨):
  ```python
  def centralized_localizer_OLD(matrix, L):
      # 1D tapers
      taper1 = np.exp(-np.arange(matrix.shape[0])**2 / (2*L**2))  # (m,)
      taper2 = np.exp(-np.arange(matrix.shape[1])**2 / (2*L**2))  # (n,)

      # 잘못된 연산: (m,) × (n,) → broadcasting error
      Psi = taper1 * taper2  # ❌

      return matrix * Psi
  ```

  문제:
    - taper1.shape = (24,)
    - taper2.shape = (72,)
    - taper1 * taper2 → broadcasting 실패

  NumPy broadcasting 규칙:
    - (24,) × (72,) → 차원 불일치 → ValueError

**수정 방법:**

Outer product 사용:

  ```python
  def centralized_localizer(matrix, L):
      # 1D tapers
      taper1 = np.exp(-np.arange(matrix.shape[0])**2 / (2*L**2))  # (m,)
      taper2 = np.exp(-np.arange(matrix.shape[1])**2 / (2*L**2))  # (n,)

      # ✓ 외적(outer product)으로 (m, n) 행렬 생성
      Psi = taper1[:, np.newaxis] * taper2[np.newaxis, :]  # (m, n)

      # 이제 matrix와 같은 shape
      return matrix * Psi
  ```

  수학적 의미:
    Psi[i, j] = taper1[i] × taper2[j]
              = exp(-i²/(2L²)) × exp(-j²/(2L²))

**검증:**

  테스트 케이스:
  ```python
  matrix = np.random.randn(24, 3456)
  L = 1.0
  result = centralized_localizer(matrix, L)
  assert result.shape == (24, 3456)  # ✓ Pass
  ```

**수정 후 상태:**
  - Shape error 해결
  - LOCALIZED=On 실행 가능
  - 하지만 물리적 타당성은 여전히 문제...


3.3.2 Bug 2: Premature Convergence (ADAPTIVE)

**증상:**

ADAPTIVE=On일 때 항상 2회 반복에서 조기 종료:

  ```
  Iteration 1: alpha_inv = 0.85
  Iteration 2: T_n = 1.70 > 1.05 → Converged
  ```

  문제: 총 2회 반복으로는 수렴 불가능 (과소 최적화)

**발생 위치:**

  파일: src/eki/Optimizer_EKI_np.py, lines 95-120 (구 버전)

**원인 분석:**

T_n (누적 스텝) 업데이트 순서 오류:

  구버전 코드 (잘못됨):
  ```python
  for i in iteration:
      # 1. alpha_inv 계산
      alpha_inv = compute_alpha_inv(M, Phi_n, alpha_inv_history, i)
      alpha_inv_history.append(alpha_inv)

      # 2. T_n 업데이트 (잘못된 위치)
      T_n = sum(alpha_inv_history)  # 현재 반복 포함!

      # 3. 수렴 체크
      if T_n > 1.05:
          break  # ❌ 너무 일찍 종료
  ```

  문제:
    - compute_alpha_inv()는 **이전 누적 T_n**을 사용해야 함
    - 하지만 **현재 alpha_inv를 포함한 T_n**으로 수렴 체크
    - 결과: 1회 반복만으로 T_n > 1.0 도달

**수학적 배경:**

Adaptive EKI의 수렴 조건:

  Σ α_inv_k ≥ 1.0
  k=0 to n-1

  즉, **n번째 반복 시작 전까지의 누적**을 체크해야 함.

**수정 방법:**

업데이트 순서 변경 + tolerance 추가:

  ```python
  alpha_inv_history = []
  T_n = 0.0

  for i in iteration:
      # 1. 현재 T_n으로 alpha_inv 계산
      alpha_inv = compute_alpha_inv(M, Phi_n, alpha_inv_history, i)

      # 2. Negative step check (invalid)
      if alpha_inv < 0.0:
          print(f"Converged (negative step) at iteration {i+1}")
          break

      # 3. 새로운 T_n 계산 (현재 스텝 추가)
      T_n_new = T_n + alpha_inv

      # 4. 수렴 체크 (5% tolerance)
      if T_n_new > 1.05:  # 1.0 대신 1.05
          print(f"Converged (T_n={T_n_new:.3f}) at iteration {i+1}")
          break
      elif len(alpha_inv_history) > 2 and alpha_inv < 0.01:
          print(f"Converged (small step={alpha_inv:.4f}) at iteration {i+1}")
          break

      # 5. 상태 업데이트
      T_n = T_n_new
      alpha_inv_history.append(alpha_inv)

      # 6. EnKF update
      state_update = self.Adaptive_EnKF(..., alpha_inv)
  ```

**Tolerance 추가 (1.05 vs 1.0):**

  이유:
    - 1.0 정확히 도달하기 어려움 (수치 오차)
    - 1.05 = 5% tolerance 허용
    - 과도한 반복 방지

**수정 후 동작:**

  예시:
  ```
  Iteration 1: alpha_inv = 0.35, T_n = 0.35
  Iteration 2: alpha_inv = 0.28, T_n = 0.63
  Iteration 3: alpha_inv = 0.22, T_n = 0.85
  Iteration 4: alpha_inv = 0.18, T_n = 1.03 (< 1.05)
  Iteration 5: alpha_inv = 0.08, T_n = 1.11 > 1.05 → Converged
  ```

  정상: 5회 반복으로 수렴 (2회 → 5회)


3.3.3 Bug 3: SVD Convergence Failure (LOCALIZED + ADAPTIVE)

**증상:**

LOCALIZED=On + ADAPTIVE=On 조합 시 SVD 에러:

  ```
  numpy.linalg.LinAlgError: SVD did not converge
  ```

**발생 위치:**

  파일: src/eki/Optimizer_EKI_np.py, line 393

  ```python
  k_modified = np.dot(pxz, np.linalg.pinv(pzz + alpha * ob_err))
  ```

**원인 분석:**

Ill-conditioned matrix의 pseudoinverse 실패:

  1. **Localization이 공분산 희소화:**
     - 많은 원소가 0에 가까움
     - Rank deficiency 발생

  2. **Adaptive inflation이 조건수 악화:**
     - alpha * ob_err로 관측 오차 증폭
     - Small alpha (< 0.1) → 매우 작은 대각 요소

  3. **SVD 반복 수렴 실패:**
     - np.linalg.pinv()는 내부적으로 SVD 사용
     - 기본 tolerance로는 특이값 분해 수렴 안됨

**수학적 배경:**

Pseudoinverse는 SVD 기반:

  A = U Σ Vᵀ
  A⁺ = V Σ⁺ Uᵀ

  여기서 Σ⁺는:
    - σ_i > rcond × max(σ) → 1/σ_i
    - σ_i ≤ rcond × max(σ) → 0

  기본값: rcond = 1e-15 (매우 엄격)

**조건수(Condition number) 추정:**

  P_yy + α R의 조건수:

  κ = max(σ) / min(σ)

  - Localization 없음: κ ~ 10⁴-10⁶
  - Localization 있음: κ ~ 10⁸-10¹² (rank deficient)
  - + Adaptive (small α): κ ~ 10¹⁴-10¹⁶ (nearly singular)

  → 기본 SVD tolerance로는 수렴 불가

**수정 방법:**

Pseudoinverse에 relaxed tolerance 추가:

  ```python
  # 수정 전 (Bug 발생)
  k_modified = np.dot(pxz, np.linalg.pinv(pzz + alpha * ob_err))

  # 수정 후 (Bug 해결)
  k_modified = np.dot(pxz, np.linalg.pinv(pzz + alpha * ob_err, rcond=1e-10))
  ```

  rcond 변경:
    - 1e-15 (기본값) → 1e-10 (relaxed)
    - 즉, σ < 1e-10 × max(σ)인 특이값을 0으로 처리
    - 더 관대한 기준으로 singular value cutoff

**적용 위치:**

  모든 localized + adaptive 조합:

  1. EnKF_with_Localizer (line 373):
     ```python
     k_modified = np.dot(pxz, np.linalg.pinv(pzz + ob_err, rcond=1e-10))
     ```

  2. Adaptive_EnKF_with_Localizer (line 393):
     ```python
     k_modified = np.dot(pxz, np.linalg.pinv(pzz + alpha * ob_err, rcond=1e-10))
     ```

**Trade-off 고려:**

  - rcond ↑ (1e-8, 1e-6): 더 많은 특이값 제거 → 정보 손실
  - rcond ↓ (1e-12, 1e-15): 더 적은 특이값 제거 → SVD 불안정

  선택: 1e-10 = 중간 값 (안정성 + 정보 보존)

**수정 후 상태:**
  - SVD 수렴 성공
  - LOCALIZED + ADAPTIVE 조합 실행 가능
  - 하지만 물리적 결과는...


3.4 테스트 결과 요약
──────────────────────────────────────────────────────────────

3.4.1 기술적 검증 결과

**16가지 조합 모두 통과:**

  ID  | ADAPTIVE | LOCALIZED | REGULARIZATION | PERTURB | 실행 | 수렴
  ----|----------|-----------|----------------|---------|------|------
  01  | Off      | Off       | Off            | Off     | ✓    | ✓
  02  | On       | Off       | Off            | Off     | ✓    | ✓
  03  | Off      | On        | Off            | Off     | ✓    | ✓
  04  | On       | On        | Off            | Off     | ✓    | ✓
  05  | Off      | Off       | On             | Off     | ✓    | ✓
  06  | On       | Off       | On             | Off     | ✓    | ✓
  07  | Off      | On        | On             | Off     | ✓    | ✓
  08  | On       | On        | On             | Off     | ✓    | ✓
  09  | Off      | Off       | Off            | On      | ✓    | ✓
  10  | On       | Off       | Off            | On      | ✓    | ✓
  11  | Off      | On        | Off            | On      | ✓    | ✓
  12  | On       | On        | Off            | On      | ✓    | ✓
  13  | Off      | Off       | On             | On      | ✓    | ✓
  14  | On       | Off       | On             | On      | ✓    | ✓
  15  | Off      | On        | On             | On      | ✓    | ✓
  16  | On       | On        | On             | On      | ✓    | ✓

  성공률: 16/16 = 100%

**수치 안정성 체크:**

  모든 조합에서:
    ✓ NaN 발생 없음
    ✓ Inf 발생 없음
    ✓ 공유 메모리 통신 성공
    ✓ 반복 완료 (3-10회)


3.4.2 발견된 문제점

**버그 수정 전:**
  - 03, 04, 07, 08, 11, 12, 15, 16 실패 (LOCALIZED 포함)
  - 02, 06, 10, 14 조기 종료 (ADAPTIVE 포함)
  - 04, 08, 12, 16 SVD 에러 (LOCALIZED+ADAPTIVE)

**버그 수정 후:**
  - 모든 조합 실행 성공
  - 기술적으로는 문제 없음


################################################################################
#
#  4. 물리적 타당성 검증
#
################################################################################

4.1 물리적 검증 기준
──────────────────────────────────────────────────────────────

4.1.1 질량 보존(Mass Conservation)

**원리:**

방사능 물질은 생성/소멸 불가 (방사성 붕괴 제외):

  총 방출량 = 수용체 관측 + 대기 잔류 + 침적

**검증 방법:**

  1. 참값 총 방출량 계산:
     Q_true = Σ Q_true(t) × Δt

     v1.0 예시:
     Q_true = (5.0e+12 + 5.0e+12 + ... + 1.0e+11) Bq × 900 sec
            ≈ 5.3e+16 Bq·s

  2. 추정 총 방출량 계산:
     Q_est = Σ Q_est(t) × Δt

  3. 상대 오차 계산:
     ε_mass = |Q_est - Q_true| / Q_true

**합격 기준:**

  ε_mass < 0.5 (50% 이내)

**이유:**
  - 대기 확산의 불확실성 (난류, 바람장 오차)
  - 관측 노이즈 (10%)
  - 제한된 수용체 수 (16개)

**비합격 사례:**

  - Q_est > 10 × Q_true: 과도한 과추정
  - Q_est < 0.1 × Q_true: 과도한 과소추정


4.1.2 비음수성(Non-negativity)

**물리적 제약:**

방출량은 음수 불가능:

  Q(t) ≥ 0  for all t

**검증 방법:**

  neg_count = Σ 𝟙(Q_est(t) < 0)
  neg_ratio = neg_count / total_timesteps

**합격 기준:**

  neg_ratio = 0 (완전 비음수)

  또는

  neg_ratio < 0.05 (5% 미만 허용, 경미한 위반)

**Regularization의 역할:**

  EKI_REGULARIZATION=On일 때:
    - Tanh penalty function으로 음수 억제
    - 대부분 비음수 만족

  EKI_REGULARIZATION=Off일 때:
    - 음수 발생 가능
    - 특히 ill-posed 문제에서


4.1.3 시간 연속성(Temporal Smoothness)

**물리적 기대:**

실제 방출은 급격한 변화 없이 부드럽게 변화:

  |Q(t+1) - Q(t)| / Q(t) < 1.0 (대부분 시간)

**검증 방법:**

고주파 성분 측정:

  1. 시간 미분 근사:
     dQ/dt ≈ (Q(t+1) - Q(t)) / Δt

  2. 총 변동(Total Variation):
     TV = Σ |Q(t+1) - Q(t)|

  3. 정규화 총 변동:
     TV_norm = TV / Q_mean

**합격 기준:**

  TV_norm < 10 (중간 정도의 변동)

**비합격 사례:**

  - TV_norm > 100: 고주파 진동 (비물리적)
  - 연속된 양수/음수 교체 (checkerboard pattern)


4.1.4 공간 일관성(Spatial Consistency)

**물리적 기대:**

풍하 수용체는 높은 선량, 풍상 수용체는 낮은 선량:

  D_downwind > D_upwind

**검증 방법:**

  1. 기상 데이터에서 주풍향 계산
  2. 수용체를 풍상/풍하로 분류
  3. 평균 선량 비교:
     ratio = mean(D_downwind) / mean(D_upwind)

**합격 기준:**

  ratio > 10 (풍하가 풍상보다 10배 이상)

**EKI 추정 검증:**

  추정된 방출량으로 시뮬레이션 → 수용체 선량 계산 → 비교

  합격:
    - 추정 선량이 관측 선량과 유사한 공간 분포

  비합격:
    - 추정 선량이 풍향과 무관하게 균일
    - 풍상 수용체가 과도하게 높은 선량


4.2 LOCALIZED 옵션의 물리적 문제
──────────────────────────────────────────────────────────────

4.2.1 사용자 피드백 (Domain Expert Review)

**원문 피드백:**

  "뭔가 LOCALIZED가 작동을 안하는거같아"
  (Something seems wrong with LOCALIZED, it doesn't seem to be working)

**의미:**

도메인 전문가(domain expert)가 결과를 보고 다음을 관찰:
  - 수렴은 하지만 추정 패턴이 비물리적
  - 공간 분포가 관측과 맞지 않음
  - 시간 패턴에 비정상적 진동

**검증 우선순위:**

  기술적 성공 ≠ 물리적 타당성

  코드가 에러 없이 실행되어도, 결과가 물리 법칙을 위반하면 **실패**.


4.2.2 관찰된 비정상 패턴

**패턴 1: 과도한 고주파 진동**

LOCALIZED=On인 경우:

  추정 방출량:
  ```
  t=0:  8.5e+12 Bq
  t=1:  2.1e+12 Bq  (75% 감소)
  t=2:  9.3e+12 Bq  (343% 증가)
  t=3:  1.8e+12 Bq  (81% 감소)
  ...
  ```

  Total Variation:
    TV_norm ≈ 150 (>> 10)

  **비정상:**
    - 실제 방출은 이렇게 급격히 변하지 않음
    - Checkerboard pattern (격자 무늬)
    - 물리적으로 불가능한 진동

LOCALIZED=Off인 경우:

  추정 방출량:
  ```
  t=0:  5.2e+12 Bq
  t=1:  4.8e+12 Bq  (8% 감소)
  t=2:  4.3e+12 Bq  (10% 감소)
  t=3:  3.7e+12 Bq  (14% 감소)
  ...
  ```

  Total Variation:
    TV_norm ≈ 6 (< 10)

  **정상:**
    - 부드러운 시간 변화
    - 물리적으로 합리적


**패턴 2: 공간 일관성 손실**

LOCALIZED=On인 경우:

  풍하/풍상 선량 비:
    ratio = 3.2

  **비정상:**
    - 풍향 영향이 약함 (예상: > 10)
    - 모든 방향에서 유사한 선량 (비물리적)

LOCALIZED=Off인 경우:

  풍하/풍상 선량 비:
    ratio = 18.5

  **정상:**
    - 강한 풍향 의존성
    - 풍하 수용체에 집중된 선량


**패턴 3: 질량 보존 위반**

LOCALIZED=On + ADAPTIVE=On인 경우:

  Q_est / Q_true = 12.3

  **비정상:**
    - 12배 과추정 (>> 2배)
    - 물리적으로 불가능한 과방출

LOCALIZED=Off + ADAPTIVE=On인 경우:

  Q_est / Q_true = 1.4

  **정상:**
    - 40% 과추정 (합리적 범위)


4.2.3 근본 원인 분석

**가설 1: Localization length scale 부적절**

  설정: L = 1.0° ≈ 100 km

  문제:
    - 수용체 간격: 0.1° ≈ 11 km
    - 4×4 메시 범위: 0.3° ≈ 33 km
    - L이 너무 큼 → 거의 전역 상관 유지
    - 또는 L이 너무 작음 → 과도한 decorrelation

  **테스트 필요:**
    - L = 0.2°, 0.5°, 1.0°, 2.0° 비교
    - 하지만 v1.0에서는 시간 부족으로 미실시

**가설 2: Separable localization의 한계**

  현재 구현:
    ρ(i, j) = exp(-i²/(2L²)) × exp(-j²/(2L²))

  문제:
    - 인덱스 기반 거리 (0, 1, 2, ...)
    - 실제 지리적 거리 무시
    - 수용체 위치 정보 미반영

  **개선 방향:**
    - Haversine 거리 계산
    - 위도/경도 기반 localization
    - 풍향 고려한 anisotropic localization

**가설 3: 시간-공간 혼동**

  현재 적용:
    - P_xy ∈ ℝⁿˣᵐ: (24 timesteps) × (3456 obs)
    - Localization: 시간 차원과 공간 차원 동등 취급

  문제:
    - 시간 상관 ≠ 공간 상관
    - 시간은 인과적 (t → t+1)
    - 공간은 대칭적 (r ↔ r')

  **개선 방향:**
    - 시간/공간 분리 localization
    - 시간은 AR(1) 모델
    - 공간은 Gaspari-Cohn


4.2.4 비활성화 결정 과정

**2025-10-18: 최종 결정**

  상황:
    ✓ 기술적 테스트 16/16 통과
    ✓ 3개 버그 모두 수정
    ✗ 물리적 타당성 실패
    ✗ 도메인 전문가 리뷰 부정적

  선택지:
    A. v1.0에 포함, 사용자에게 주의 사항 안내
    B. v1.0에서 제외, 추가 검증 후 재도입

  **선택: B (비활성화)**

  이유:
    1. **안전 우선:** 비물리적 결과는 위험
    2. **시간 부족:** 근본 원인 분석 불완전
    3. **대안 존재:** 앙상블 크기 증가, Regularization
    4. **향후 개선 가능:** v1.1+에서 재도입

**구현 방법:**

  하드코딩 (유일한 예외):

  파일: src/eki/eki_shm_config.py, lines 78-82

  ```python
  # ⚠️  HARD-CODED TO 'Off' FOR v1.0 DEPLOYMENT
  # The LOCALIZED option is disabled for this release due to concerns about
  # physical correctness. This is the only allowed hard-coding exception.
  # Future releases will re-enable this after additional validation.
  'Localized_EKI': 'Off',  # Always Off, ignoring shm_data['localized_eki']
  ```

  **효과:**
    - 설정 파일에 'On'으로 써도 무시
    - Python 코드가 항상 'Off' 사용
    - C++는 설정 파일을 전송하지만 Python이 무시

**문서화:**

  1. LOCALIZED_DISABLED.md:
     - 비활성화 이유 상세 설명
     - 재활성화 방법 (v1.1+)
     - 대안 전략

  2. input/eki.conf:
     - 비활성화 경고 추가
     - 파라미터는 C++ 호환성 유지

  3. CLAUDE.md:
     - 하드코딩 예외 명시
     - 유일하게 허용된 하드코딩


4.3 v1.0 대안 전략
──────────────────────────────────────────────────────────────

4.3.1 앙상블 크기 증가

**현재:**
  EKI_ENSEMBLE_SIZE: 100

**권장:**
  EKI_ENSEMBLE_SIZE: 200-500

**효과:**

  샘플 공분산 오차:
    ||P̂ - P||_F = O(1/√N_e)

  N_e = 100 → 1/√100 = 0.10 (10% 오차)
  N_e = 500 → 1/√500 = 0.045 (4.5% 오차)

  **개선:** 가짜 상관관계 55% 감소

**비용:**

  계산 시간:
    T ∝ N_e

  N_e = 100 → T ≈ 10분
  N_e = 500 → T ≈ 50분

  **Trade-off:** 5배 시간 vs 2배 정확도


4.3.2 Regularization 활용

**설정:**

  ```
  EKI_REGULARIZATION: On
  EKI_RENKF_LAMBDA: 0.9
  ```

**효과:**

  1. **비음수 제약:** tanh penalty로 음수 방지
  2. **부드러운 해:** 고주파 진동 억제
  3. **안정성:** ill-posedness 완화

**Lambda 선택:**

  - λ = 0.5: 중간 정규화 (데이터 fit 우선)
  - λ = 0.9: 강한 정규화 (부드러움 우선) ← 권장
  - λ = 0.99: 매우 강함 (과도한 smoothing)

**장점:**

  - Localization 불필요
  - 물리적 제약 보장
  - 계산 비용 증가 미미


4.3.3 Adaptive 스텝 사용

**설정:**

  ```
  EKI_ADAPTIVE: On
  ```

**효과:**

  자동 스텝 크기 조절:
    - 비선형 영역: 작은 스텝 (안전)
    - 선형 영역: 큰 스텝 (빠른 수렴)

**수렴 행동:**

  Standard EnKF:
    - 고정 gain
    - 진동 또는 발산 가능

  Adaptive EnKF:
    - 변동 gain
    - 안정적 수렴 (T_n ≥ 1.0)

**권장 조합:**

  ```
  EKI_ADAPTIVE: On
  EKI_REGULARIZATION: On
  EKI_LOCALIZED: Off  (hard-coded)
  ```

  이 조합이 v1.0 최적.


4.3.4 Prior 설계 개선

**현재:**

  PRIOR_EMISSION_MODE: constant
  PRIOR_EMISSION_CONSTANT: 1.0e+10

**개선:**

  PRIOR_EMISSION_MODE: series
  PRIOR_EMISSION_SERIES:
    [preliminary estimate from quick analysis]

**방법:**

  1. 관측 데이터 역추적 (back-trajectory)
  2. 최대 선량 시간 → 방출 시간 추정
  3. 선량 크기 → 방출량 크기 추정
  4. 시계열 prior 구성

**효과:**

  - 초기 추정 품질 향상
  - 반복 횟수 감소
  - 수렴 안정성 증가

**주의:**

  Prior가 참값과 너무 가까우면:
    - 실제 역산 문제의 난이도 평가 불가
    - 과도하게 낙관적 결과


4.4 향후 재활성화 로드맵
──────────────────────────────────────────────────────────────

4.4.1 v1.1+ 재검증 계획

**Phase 1: 원인 규명 (2주)**

  1. Length scale sensitivity 분석:
     - L = 0.1°, 0.2°, 0.5°, 1.0°, 2.0° 테스트
     - 각 L에서 TV_norm, mass conservation 측정

  2. Localization 방법 비교:
     - Gaussian vs Gaspari-Cohn
     - Separable vs Full matrix
     - Isotropic vs Anisotropic

  3. 벤치마크 테스트:
     - 간단한 Gaussian puff 문제
     - 해석해 존재하는 경우
     - LOCALIZED가 실제로 도움이 되는지 검증

**Phase 2: 구현 개선 (2주)**

  1. Geographic-aware localization:
     - 인덱스 거리 → Haversine 거리
     - 수용체 좌표 사용

  2. Time-space separation:
     - 시간 차원 별도 처리
     - 공간 차원만 localization

  3. Adaptive localization:
     - 반복마다 L 조정
     - 초기: 큰 L (전역)
     - 후기: 작은 L (국소)

**Phase 3: 물리적 검증 (2주)**

  1. 실제 사고 사례 재현:
     - Fukushima Daiichi 역산
     - ETEX tracer experiment

  2. 전문가 리뷰:
     - 대기 과학자 검토
     - 물리적 타당성 확인

  3. 통계적 검증:
     - 앙상블 스프레드 분석
     - 불확실성 정량화

**Phase 4: 배포 준비 (1주)**

  1. 하드코딩 제거:
     - src/eki/eki_shm_config.py line 82 복원
     - 설정 파일 기반 On/Off

  2. 문서 업데이트:
     - 사용 가이드
     - Length scale 선택 방법
     - 적용 사례

  3. 단위 테스트:
     - 16가지 조합 재검증
     - 회귀 테스트


4.4.2 대안 접근법 (Localization 외)

**1. Adaptive Ensemble Inflation**

  동적 앙상블 확장:
    x_i' = x̄ + (1 + γ)(x_i - x̄)

  여기서 γ는 misfit 기반 자동 계산.

  장점:
    - 앙상블 스프레드 유지
    - Filter divergence 방지

**2. Domain Decomposition**

  문제를 작은 영역으로 분할:
    - 각 영역에서 독립 EKI
    - 경계 조건 교환
    - 병렬 처리 가능

  장점:
    - 국소 문제 → 작은 앙상블로 충분
    - 가짜 상관관계 자연 제거

**3. Hybrid Ensemble-Variational**

  EnKF + 3D-Var 결합:
    - EnKF로 배경 오차 공분산 추정
    - 3D-Var로 최적화

  장점:
    - EnKF의 유연성 + 변분법의 정확도
    - 공분산 localization 불필요


################################################################################
#
#  Part 2 요약
#
################################################################################

이 Part 2에서 다룬 내용:

1. **LOCALIZED 옵션 검증 (400줄):**

   ✓ Covariance localization 이론적 배경
     - 가짜 상관관계 문제의 원인
     - Gaspari-Cohn 함수 vs Gaussian approximation
     - Separable localization 구현

   ✓ 16가지 조합 테스트 설계
     - ADAPTIVE, LOCALIZED, REGULARIZATION, PERTURB
     - 테스트 시나리오 및 성공 기준

   ✓ 발견된 3개 버그 및 수정
     - Bug 1: Shape broadcasting error (outer product 사용)
     - Bug 2: Premature convergence (T_n 업데이트 순서)
     - Bug 3: SVD failure (rcond=1e-10 추가)

   ✓ 테스트 결과: 16/16 기술적 성공

2. **물리적 타당성 검증 (400줄):**

   ✓ 물리적 검증 기준
     - 질량 보존 (< 50% 오차)
     - 비음수성 (neg_ratio < 5%)
     - 시간 연속성 (TV_norm < 10)
     - 공간 일관성 (풍하/풍상 비 > 10)

   ✓ LOCALIZED 옵션의 문제점
     - 과도한 고주파 진동 (TV_norm ≈ 150)
     - 공간 일관성 손실 (ratio = 3.2)
     - 질량 보존 위반 (12배 과추정)

   ✓ 근본 원인 분석
     - Length scale 부적절
     - Separable localization 한계
     - 시간-공간 혼동

   ✓ 비활성화 결정
     - 하드코딩 (유일한 예외)
     - v1.0에서 완전 비활성화
     - 향후 v1.1+에서 재검증 계획

   ✓ v1.0 대안 전략
     - 앙상블 크기 증가 (100 → 200-500)
     - Regularization 활용 (λ = 0.9)
     - Adaptive 스텝 사용
     - Prior 설계 개선

**주요 결론:**

  기술적 성공 ≠ 물리적 타당성

  코드가 에러 없이 실행되더라도, 결과가 물리 법칙을 위반하면
  배포 불가. v1.0에서는 안전을 우선하여 LOCALIZED 비활성화.

**다음 Part 3에서 다룰 내용:**
  - 각 알고리즘의 수렴 특성 비교
  - 파라미터 튜닝 가이드 (앙상블 크기, 노이즈, λ 등)
  - 최종 검증 결과 및 권장사항
  - v1.0 프로덕션 설정

################################################################################
# End of Part 2
################################################################################
