================================================================================
LDM-EKI IPC 통신 시스템 보고서 (Part 1 of 3)
================================================================================

작성일: 2025년 10월 18일
작성자: Claude Code (LDM-EKI IPC 통신 시스템 전문가)
버전: v1.0 Release

본 보고서는 LDM-EKI 시스템의 프로세스 간 통신(IPC) 메커니즘을 상세히 문서화합니다.
Part 1은 개요, 아키텍처, C++ IPC 구현, 데이터 구조체를 다룹니다.

================================================================================
목차 (Part 1)
================================================================================

1. 개요 및 아키텍처
   1.1 IPC의 필요성과 역할
   1.2 POSIX 공유 메모리 선택 이유
   1.3 대안 기술 비교
   1.4 2-프로세스 설계 철학

2. C++ IPC Writer 구현
   2.1 EKIWriter 클래스 개요
   2.2 초기화 메서드
   2.3 초기 관측값 전송
   2.4 앙상블 관측값 전송
   2.5 참값 방출량 전송
   2.6 정리 및 메모리 해제

3. 데이터 구조체
   3.1 EKIConfigFull 구조체 (84 바이트)
   3.2 EKIConfigBasic 구조체 (12 바이트)
   3.3 EKIDataHeader 구조체
   3.4 EnsembleConfig 구조체
   3.5 EnsembleDataHeader 구조체
   3.6 메모리 레이아웃 및 패딩

================================================================================
1. 개요 및 아키텍처
================================================================================

1.1 IPC의 필요성과 역할
────────────────────────────────────────────────────────────────────────────

LDM-EKI는 두 개의 독립적인 프로세스로 구성된 방사능 오염원 추정 시스템입니다:

[프로세스 1: LDM (C++/CUDA)]
  • 역할: 순방향 입자 확산 시뮬레이션
  • 언어: C++17 + CUDA
  • 주요 작업:
    - GPU에서 CUDA 커널 실행
    - 수십만~수백만 개 입자 추적
    - 수용체 위치에서 관측값 수집
    - 기상 데이터 사전 로딩 및 캐싱
  • 실행파일: ./ldm-eki

[프로세스 2: EKI (Python)]
  • 역할: 앙상블 칼만 역산 최적화
  • 언어: Python 3.8+
  • 주요 작업:
    - 관측값 기반 오염원 추정
    - 앙상블 칼만 필터 알고리즘 실행
    - 사전 분포 생성 및 업데이트
    - 수렴 판정 및 반복 제어
  • 실행파일: src/eki/RunEstimator.py

**IPC의 역할:**
두 프로세스 간 고속 데이터 교환을 담당합니다. 매 반복마다 다음 데이터를 전송:

  C++ → Python:
    • 초기 참값 관측값 (1회, 시작 시)
    • 앙상블 관측값 (반복마다, 수백 KB)
    • 설정 파라미터 (84 바이트)

  Python → C++:
    • 앙상블 상태 벡터 (반복마다, 수십 KB)
    • 수렴 신호 (간접적, 데이터 부재로 표현)


1.2 POSIX 공유 메모리 선택 이유
────────────────────────────────────────────────────────────────────────────

LDM-EKI는 **POSIX 공유 메모리 (shm_open/mmap)** 를 IPC 메커니즘으로 채택했습니다.

**핵심 장점:**

[1] 초고속 데이터 전송
    • 메모리 복사만으로 전송 완료 (네트워크/파이프 오버헤드 없음)
    • 전송 속도: ~100 MB/s (일반 디스크 대비 100배 이상)
    • 지연시간: < 1ms (TCP 소켓 대비 10~100배 빠름)

[2] Zero-Copy 아키텍처
    • 송신자가 메모리에 직접 쓰면 수신자가 즉시 읽기 가능
    • 커널 버퍼를 거치지 않음
    • CPU 및 메모리 대역폭 절약

[3] 단순한 구현
    • 표준 POSIX API 사용 (Linux/macOS/Unix 호환)
    • 파일 기반 인터페이스 (/dev/shm/파일명)
    • Python mmap 모듈로 직접 접근 가능

[4] 디버깅 용이성
    • /dev/shm/ 에서 파일로 데이터 확인 가능
    • hexdump, od 등 표준 도구로 검사
    • 프로세스 크래시 시에도 데이터 보존

[5] 대용량 데이터 처리
    • 앙상블 관측값: 100 ensembles × 24 timesteps × 16 receptors = 153 KB
    • 메모리 매핑으로 효율적 처리
    • 동적 크기 조절 가능 (ftruncate)

**사용 예시:**

```cpp
// C++ 측 (송신)
int fd = shm_open("/ldm_eki_data", O_CREAT | O_RDWR, 0660);
ftruncate(fd, data_size);
void* ptr = mmap(NULL, data_size, PROT_WRITE, MAP_SHARED, fd, 0);
memcpy(ptr, observations, data_size);
munmap(ptr, data_size);
close(fd);
```

```python
# Python 측 (수신)
import mmap
fd = os.open("/dev/shm/ldm_eki_data", os.O_RDONLY)
mm = mmap.mmap(fd, length=0, access=mmap.ACCESS_READ)
data = np.frombuffer(mm, dtype=np.float32)
mm.close()
os.close(fd)
```


1.3 대안 기술 비교
────────────────────────────────────────────────────────────────────────────

LDM-EKI 개발 과정에서 다음 IPC 기술들을 검토했습니다:

┌─────────────────┬──────────────┬─────────────┬──────────────┬─────────────┐
│ 기술            │ 전송 속도    │ 구현 복잡도 │ 디버깅 난이도│ 선택 여부   │
├─────────────────┼──────────────┼─────────────┼──────────────┼─────────────┤
│ POSIX Shared Mem│ ~100 MB/s    │ 낮음        │ 쉬움         │ ✓ 채택      │
│ TCP Socket      │ ~10 MB/s     │ 중간        │ 어려움       │ ✗ 기각      │
│ Unix Domain Sock│ ~50 MB/s     │ 중간        │ 어려움       │ ✗ 기각      │
│ Named Pipe (FIFO│ ~30 MB/s     │ 낮음        │ 중간         │ ✗ 기각      │
│ Message Queue   │ ~5 MB/s      │ 높음        │ 어려움       │ ✗ 기각      │
│ Files (tmpfs)   │ ~80 MB/s     │ 낮음        │ 쉬움         │ △ 유사      │
└─────────────────┴──────────────┴─────────────┴──────────────┴─────────────┘

**각 기술의 장단점:**

[TCP Socket]
  장점:
    • 네트워크 투명성 (로컬/원격 동일 API)
    • 잘 알려진 프로그래밍 모델
  단점:
    • 느린 속도 (커널 버퍼 복사 오버헤드)
    • 포트 충돌 가능성
    • 프로세스 시작 순서 의존성
  기각 이유: 속도가 10배 느림, LDM-EKI는 로컬 통신만 필요

[Unix Domain Socket]
  장점:
    • TCP보다 빠름 (네트워크 스택 우회)
    • 신뢰성 있는 스트림 전송
  단점:
    • 여전히 커널 버퍼 복사 필요
    • 소켓 파일 정리 필요
  기각 이유: POSIX shm보다 2배 느림

[Named Pipe (FIFO)]
  장점:
    • 단순한 파일 기반 API
    • 양방향 통신 가능
  단점:
    • 순차 접근만 가능 (랜덤 접근 불가)
    • 블로킹 I/O 처리 복잡
  기각 이유: 대용량 데이터에 비효율적

[Message Queue]
  장점:
    • 메시지 단위 전송 보장
    • 우선순위 지원
  단점:
    • 메시지 크기 제한 (일반적으로 8KB)
    • 큐 관리 오버헤드
  기각 이유: 대용량 전송에 부적합, 복잡한 API

[Files on tmpfs]
  장점:
    • POSIX shm과 거의 동일한 성능
    • 표준 파일 API 사용
  단점:
    • 명시적 동기화 필요 (fsync)
    • POSIX shm 대비 약간 느림
  참고: /dev/shm은 tmpfs 기반 (거의 동일)


**최종 선택: POSIX Shared Memory**

선택 근거:
  1. 최고 성능 (100 MB/s, < 1ms 지연)
  2. 단순한 구현 (표준 POSIX API)
  3. 디버깅 용이 (/dev/shm 파일로 검사)
  4. Python mmap 모듈과 완벽 호환
  5. Zero-copy 아키텍처
  6. 동적 크기 조절 가능


1.4 2-프로세스 설계 철학
────────────────────────────────────────────────────────────────────────────

LDM-EKI는 **단일 실행파일**이 아닌 **2-프로세스 협력 모델**을 채택했습니다.

**설계 철학:**

[철학 1] 언어별 강점 활용
  • C++/CUDA: 고성능 수치 계산, GPU 병렬화
    - 입자 추적: 수백만 입자 × 수천 타임스텝
    - CUDA 커널: 복잡한 물리 모델 (난류, 침적, 붕괴)
  • Python: 고수준 알고리즘, 빠른 프로토타이핑
    - NumPy/SciPy: 행렬 연산, 선형대수
    - 앙상블 칼만 필터: 수식 직관적 구현

[철학 2] 독립적 개발 및 테스트
  • LDM 개발자: C++/CUDA에 집중, Python 불필요
  • EKI 개발자: 알고리즘 구현, CUDA 불필요
  • 단위 테스트: 각 프로세스 독립적 검증
  • 통합 테스트: IPC 인터페이스 검증

[철학 3] 모듈화 및 재사용성
  • LDM: 다른 역산 알고리즘과 결합 가능
    - Variational Data Assimilation
    - Markov Chain Monte Carlo
    - Particle Filter
  • EKI: 다른 순방향 모델과 결합 가능
    - WRF-Chem
    - HYSPLIT
    - Custom physics models

[철학 4] 오류 격리
  • Python 크래시: C++ 프로세스 안전
  • C++ 세그폴트: Python 프로세스 계속 실행 (타임아웃 후 종료)
  • 디버깅: 각 프로세스 로그 독립 분석

**프로세스 실행 흐름:**

```
[1] 사용자가 ./ldm-eki 실행

[2] C++ 메인 프로세스 시작
    ├─ 설정 파일 읽기 (input/simulation.conf, eki.conf 등)
    ├─ 공유 메모리 생성 (/dev/shm/ldm_eki_*)
    ├─ 설정 데이터 공유 메모리에 쓰기
    └─ Python 프로세스 백그라운드 실행
        $ python3 src/eki/RunEstimator.py &

[3] Python 프로세스 시작
    ├─ 공유 메모리에서 설정 읽기
    ├─ 앙상블 초기화 (사전 분포 생성)
    └─ C++의 초기 관측값 대기

[4] C++ 참값 시뮬레이션
    ├─ 참값 방출량으로 순방향 시뮬레이션 실행
    ├─ 수용체에서 관측값 수집
    └─ 관측값을 공유 메모리에 쓰기
        /dev/shm/ldm_eki_data

[5] Python 초기 설정
    ├─ 관측값 읽기
    ├─ 사전 앙상블 생성 (예: 100 멤버)
    └─ 첫 앙상블 상태를 공유 메모리에 쓰기
        /dev/shm/ldm_eki_ensemble_config
        /dev/shm/ldm_eki_ensemble_data

[6] 반복 루프 (iteration = 1 to max_iterations)

    [C++ 대기]
    ├─ Python 앙상블 상태 대기 (polling)
    └─ 데이터 감지 시 읽기

    [C++ 앙상블 시뮬레이션]
    ├─ 각 앙상블 멤버별 순방향 시뮬레이션
    │   - 멤버 1: emission_1 → observation_1
    │   - 멤버 2: emission_2 → observation_2
    │   - ...
    │   - 멤버 100: emission_100 → observation_100
    └─ 앙상블 관측값을 공유 메모리에 쓰기
        /dev/shm/ldm_eki_ensemble_obs_config
        /dev/shm/ldm_eki_ensemble_obs_data

    [Python EKI 업데이트]
    ├─ 앙상블 관측값 읽기
    ├─ 칼만 이득 계산
    ├─ 앙상블 상태 업데이트
    ├─ 수렴 판정
    └─ 업데이트된 앙상블 상태 쓰기 (다음 반복용)

[7] 수렴 또는 최대 반복 도달
    ├─ Python: 최종 결과 저장 및 종료
    └─ C++: 공유 메모리 정리 및 종료
```

**프로세스 간 의존성:**

  Python은 C++에 의존:
    • C++가 먼저 설정을 공유 메모리에 쓰고 Python 실행
    • C++가 관측값 제공해야 Python이 역산 시작

  C++는 Python에 의존:
    • Python이 앙상블 상태 제공해야 C++가 시뮬레이션 실행
    • Python 타임아웃 시 C++도 종료

  상호 의존성:
    • 반복 루프에서 서로의 출력을 입력으로 사용
    • 동기화 메커니즘으로 데드락 방지 (polling + 타임아웃)


**설계 장점:**

  [성능]
    • 각 언어의 최적 영역 활용
    • GPU (C++/CUDA) + CPU (Python/NumPy) 병렬 실행 가능
    • IPC 오버헤드 < 1% (공유 메모리 고속)

  [유지보수성]
    • 각 프로세스 독립적 수정 가능
    • 인터페이스(IPC 구조체)만 유지하면 내부 자유롭게 변경
    • 단위 테스트 용이

  [확장성]
    • 새로운 역산 알고리즘 추가: Python만 수정
    • 새로운 물리 모델 추가: C++만 수정
    • 다른 언어로 대체 가능 (인터페이스 준수 시)

  [안정성]
    • 한 프로세스 크래시가 다른 프로세스에 영향 최소화
    • 타임아웃으로 무한 대기 방지
    • 에러 격리 및 독립적 복구


**설계 단점 및 완화 방안:**

  [단점 1] 프로세스 간 동기화 복잡도
    완화: Polling + 타임아웃 메커니즘, 단순 플래그 파일 사용

  [단점 2] IPC 오버헤드
    완화: POSIX 공유 메모리로 최소화 (< 1ms)

  [단점 3] 프로세스 생명주기 관리
    완화: Python을 C++의 자식 프로세스로 실행, 종료 시 자동 정리

  [단점 4] 디버깅 복잡도
    완화: Memory Doctor 모드, 독립적 로그 파일, 데이터 덤프 기능


================================================================================
2. C++ IPC Writer 구현
================================================================================

2.1 EKIWriter 클래스 개요
────────────────────────────────────────────────────────────────────────────

EKIWriter는 C++/CUDA LDM 프로세스에서 Python EKI 프로세스로 데이터를 전송하는
핵심 클래스입니다.

**파일 위치:**
  • 헤더: src/ipc/ldm_eki_writer.cuh
  • 구현: src/ipc/ldm_eki_writer.cu
  • 네임스페이스: LDM_EKI_IPC

**클래스 정의:**

```cpp
namespace LDM_EKI_IPC {

class EKIWriter {
private:
    int config_fd;         // 설정 파일 디스크립터
    int data_fd;           // 데이터 파일 디스크립터
    void* config_map;      // 설정 메모리 맵 포인터
    void* data_map;        // 데이터 메모리 맵 포인터
    size_t data_size;      // 데이터 세그먼트 크기
    bool initialized;      // 초기화 상태 플래그

public:
    // 생성자/소멸자
    EKIWriter();
    ~EKIWriter();

    // 초기화
    bool initialize(const ::EKIConfig& eki_config, int num_timesteps);

    // 초기 관측값 전송
    bool writeObservations(const float* observations, int rows, int cols);

    // 앙상블 관측값
    bool initializeEnsembleObservations(int ensemble_size,
                                        int num_receptors,
                                        int num_timesteps);
    bool writeEnsembleObservations(const float* observations,
                                   int ensemble_size,
                                   int num_receptors,
                                   int num_timesteps,
                                   int iteration = -1);

    // 참값 방출량 전송
    bool writeTrueEmissions(const std::vector<float>& emissions);

    // 설정 조회
    bool getConfig(int& ensemble_size, int& num_receptors, int& num_timesteps);

    // 정리
    void cleanup();
    static void unlinkSharedMemory();
};

} // namespace LDM_EKI_IPC
```

**주요 멤버 변수:**

  config_fd (int):
    • /dev/shm/ldm_eki_config 파일 디스크립터
    • shm_open()으로 생성
    • 초기화 시 열고 소멸 시 닫음

  data_fd (int):
    • /dev/shm/ldm_eki_data 파일 디스크립터
    • 초기 관측값 저장
    • 크기: sizeof(EKIDataHeader) + (receptors × timesteps × sizeof(float))

  config_map (void*):
    • 설정 구조체 메모리 매핑 포인터
    • 실제 타입: EKIConfigFull* (84 바이트)
    • mmap()으로 매핑, munmap()으로 해제

  data_map (void*):
    • 관측값 데이터 메모리 매핑 포인터
    • 레이아웃: [EKIDataHeader | float 배열]
    • 동적 크기 (수용체 및 타임스텝 수에 따라)

  data_size (size_t):
    • data_fd 세그먼트 전체 크기
    • 계산: sizeof(EKIDataHeader) + rows × cols × sizeof(float)
    • mmap() 및 munmap() 시 사용

  initialized (bool):
    • 초기화 상태 플래그
    • true: initialize() 성공 완료
    • false: 아직 초기화 안 됨 또는 cleanup() 후


**공유 메모리 세그먼트 이름:**

```cpp
// src/ipc/ldm_eki_writer.cuh

constexpr const char* SHM_CONFIG_NAME = "/ldm_eki_config";
constexpr const char* SHM_DATA_NAME = "/ldm_eki_data";
constexpr const char* SHM_ENSEMBLE_OBS_CONFIG_NAME = "/ldm_eki_ensemble_obs_config";
constexpr const char* SHM_ENSEMBLE_OBS_DATA_NAME = "/ldm_eki_ensemble_obs_data";
constexpr const char* SHM_TRUE_EMISSIONS_NAME = "/ldm_eki_true_emissions";
```

실제 파일 경로:
  • /dev/shm/ldm_eki_config (84 bytes)
  • /dev/shm/ldm_eki_data (가변 크기)
  • /dev/shm/ldm_eki_ensemble_obs_config (12 bytes)
  • /dev/shm/ldm_eki_ensemble_obs_data (가변 크기)
  • /dev/shm/ldm_eki_true_emissions (num_timesteps × 4 bytes)


**생성자 및 소멸자:**

```cpp
// src/ipc/ldm_eki_writer.cu

EKIWriter::EKIWriter()
    : config_fd(-1), data_fd(-1), config_map(nullptr),
      data_map(nullptr), data_size(0), initialized(false) {
    // 모든 멤버를 안전한 초기값으로 설정
    // -1: 유효하지 않은 파일 디스크립터
    // nullptr: 유효하지 않은 포인터
}

EKIWriter::~EKIWriter() {
    cleanup();  // 자동으로 리소스 해제
}
```

생성자 특징:
  • 멤버 초기화 리스트로 모든 변수 초기화
  • 파일 디스크립터를 -1로 (유효하지 않은 값)
  • 포인터를 nullptr로 (안전한 초기값)
  • 실제 공유 메모리 생성은 initialize()에서 수행

소멸자 특징:
  • cleanup() 호출로 리소스 자동 해제
  • RAII (Resource Acquisition Is Initialization) 패턴
  • 예외 안전 보장


2.2 초기화 메서드
────────────────────────────────────────────────────────────────────────────

initialize() 메서드는 공유 메모리 세그먼트를 생성하고 설정을 쓰는 핵심 함수입니다.

**함수 시그니처:**

```cpp
bool EKIWriter::initialize(const ::EKIConfig& eki_config, int num_timesteps);
```

**매개변수:**
  • eki_config: EKI 설정 구조체 (전역 변수 g_eki에서 전달)
  • num_timesteps: 시뮬레이션 타임스텝 수 (예: 216)

**반환값:**
  • true: 초기화 성공
  • false: 실패 (오류 메시지 stderr 출력)

**구현 코드 (전체):**

```cpp
// src/ipc/ldm_eki_writer.cu

bool EKIWriter::initialize(const ::EKIConfig& eki_config, int num_timesteps) {
    // [1] 중복 초기화 방지
    if (initialized) {
        std::cerr << "EKIWriter already initialized" << std::endl;
        return false;
    }

    // [2] 데이터 크기 계산
    // 헤더(12바이트) + 관측값 배열
    data_size = sizeof(EKIDataHeader) +
                eki_config.num_receptors * num_timesteps * sizeof(float);

    // [3] 설정 공유 메모리 생성
    config_fd = shm_open(SHM_CONFIG_NAME, O_CREAT | O_RDWR, 0660);
    if (config_fd < 0) {
        perror("shm_open config");
        return false;
    }

    // [4] 설정 크기 설정 (84 바이트)
    if (ftruncate(config_fd, sizeof(EKIConfigFull)) != 0) {
        perror("ftruncate config");
        close(config_fd);
        return false;
    }

    // [5] 설정 메모리 매핑
    config_map = mmap(nullptr, sizeof(EKIConfigFull),
                     PROT_READ | PROT_WRITE,
                     MAP_SHARED, config_fd, 0);
    if (config_map == MAP_FAILED) {
        perror("mmap config");
        close(config_fd);
        return false;
    }

    // [6] 설정 구조체 작성
    auto* config = reinterpret_cast<EKIConfigFull*>(config_map);
    memset(config, 0, sizeof(EKIConfigFull));  // 전체 0으로 초기화

    // 기본 정보 (12 bytes)
    config->ensemble_size = eki_config.ensemble_size;
    config->num_receptors = eki_config.num_receptors;
    config->num_timesteps = num_timesteps;

    // 알고리즘 파라미터 (24 bytes)
    config->iteration = eki_config.iteration;
    config->renkf_lambda = eki_config.renkf_lambda;
    config->noise_level = eki_config.noise_level;
    config->time_interval = eki_config.time_interval;
    config->prior_constant = eki_config.prior_constant;

    // 핵종 붕괴 상수 (NuclideConfig에서 가져오기)
    NuclideConfig* nuc_config = NuclideConfig::getInstance();
    config->decay_constant = (nuc_config->getNumNuclides() > 0) ?
                             nuc_config->getDecayConstant(0) : 0.0f;

    // 옵션 문자열 (40 bytes = 5 × 8 bytes)
    memset(config->perturb_option, 0, 8);
    strncpy(config->perturb_option, eki_config.perturb_option.c_str(), 7);

    memset(config->adaptive_eki, 0, 8);
    strncpy(config->adaptive_eki, eki_config.adaptive_eki.c_str(), 7);

    memset(config->localized_eki, 0, 8);
    strncpy(config->localized_eki, eki_config.localized_eki.c_str(), 7);

    memset(config->regularization, 0, 8);
    strncpy(config->regularization, eki_config.regularization.c_str(), 7);

    memset(config->time_unit, 0, 8);
    strncpy(config->time_unit, eki_config.time_unit.c_str(), 7);

    // Memory Doctor 모드 (8 bytes)
    memset(config->memory_doctor, 0, 8);
    strncpy(config->memory_doctor,
            eki_config.memory_doctor_mode ? "On" : "Off", 7);

    // [7] 데이터 공유 메모리 생성
    data_fd = shm_open(SHM_DATA_NAME, O_CREAT | O_RDWR, 0660);
    if (data_fd < 0) {
        perror("shm_open data");
        munmap(config_map, sizeof(EKIConfigFull));
        close(config_fd);
        return false;
    }

    // [8] 데이터 크기 설정
    if (ftruncate(data_fd, data_size) != 0) {
        perror("ftruncate data");
        munmap(config_map, sizeof(EKIConfigFull));
        close(config_fd);
        close(data_fd);
        return false;
    }

    // [9] 데이터 메모리 매핑
    data_map = mmap(nullptr, data_size,
                   PROT_READ | PROT_WRITE,
                   MAP_SHARED, data_fd, 0);
    if (data_map == MAP_FAILED) {
        perror("mmap data");
        munmap(config_map, sizeof(EKIConfigFull));
        close(config_fd);
        close(data_fd);
        return false;
    }

    // [10] 데이터 헤더 초기화
    auto* header = reinterpret_cast<EKIDataHeader*>(data_map);
    header->status = 0;  // 0 = 아직 쓰는 중
    header->rows = eki_config.num_receptors;
    header->cols = num_timesteps;

    // [11] 초기화 완료
    initialized = true;
    std::cout << Color::CYAN << "[IPC] " << Color::RESET
              << "Writer initialized with full configuration\n";
    std::cout << "  Ensembles      : " << Color::BOLD
              << eki_config.ensemble_size << Color::RESET << "\n";
    std::cout << "  Receptors      : " << Color::BOLD
              << eki_config.num_receptors << Color::RESET << "\n";
    std::cout << "  Timesteps      : " << Color::BOLD
              << num_timesteps << Color::RESET << "\n";
    std::cout << "  Iteration      : " << eki_config.iteration << "\n";
    std::cout << "  Regularization : " << eki_config.regularization << "\n";
    return true;
}
```

**단계별 설명:**

[1] 중복 초기화 방지
    • initialized 플래그 확인
    • 이미 초기화된 경우 오류 메시지 출력 후 false 반환
    • 메모리 누수 및 파일 디스크립터 낭비 방지

[2] 데이터 크기 계산
    • 헤더 크기: sizeof(EKIDataHeader) = 12 bytes
    • 관측값 배열 크기: receptors × timesteps × sizeof(float)
    • 예시: 16 receptors × 216 timesteps × 4 bytes = 13,824 bytes
    • 총 크기: 12 + 13,824 = 13,836 bytes

[3] 설정 공유 메모리 생성
    • shm_open(name, flags, mode)
      - name: "/ldm_eki_config"
      - flags: O_CREAT (없으면 생성) | O_RDWR (읽기/쓰기)
      - mode: 0660 (소유자/그룹 읽기쓰기, 기타 없음)
    • 반환: 파일 디스크립터 (정수)
    • 실패 시 -1 반환, errno 설정

[4] 설정 크기 설정
    • ftruncate(fd, length): 파일 크기 설정
    • length: sizeof(EKIConfigFull) = 84 bytes
    • 실패 시 -1 반환, 이전 리소스 정리

[5] 설정 메모리 매핑
    • mmap(addr, length, prot, flags, fd, offset)
      - addr: nullptr (커널이 주소 선택)
      - length: 84 bytes
      - prot: PROT_READ | PROT_WRITE (읽기/쓰기 권한)
      - flags: MAP_SHARED (다른 프로세스와 공유)
      - fd: config_fd
      - offset: 0 (파일 시작부터)
    • 반환: 메모리 주소 포인터
    • 실패 시 MAP_FAILED 반환

[6] 설정 구조체 작성
    • memset()으로 전체 0 초기화 (안전성)
    • 기본 정보 (12 bytes):
      - ensemble_size: 100
      - num_receptors: 16
      - num_timesteps: 216
    • 알고리즘 파라미터 (24 bytes):
      - iteration: 10
      - renkf_lambda: 0.1
      - noise_level: 0.05
      - time_interval: 100.0 (초)
      - prior_constant: 1.0e+13 (Bq)
      - decay_constant: 6.78e-5 (Kr-88, s⁻¹)
    • 옵션 문자열 (40 bytes):
      - perturb_option: "On" 또는 "Off"
      - adaptive_eki: "On" 또는 "Off"
      - localized_eki: "Off" (v1.0에서 강제 비활성화)
      - regularization: "On" 또는 "Off"
      - time_unit: "seconds"
    • Memory Doctor (8 bytes):
      - "On" 또는 "Off"

    **문자열 복사 주의사항:**
      • strncpy(dest, src, n): 최대 n 바이트 복사
      • n = 7로 설정 (8 바이트 중 마지막 1 바이트는 null)
      • memset()으로 먼저 0 초기화 (null 종료 보장)

[7-9] 데이터 공유 메모리 생성 및 매핑
    • 설정과 동일한 프로세스
    • 파일명: "/ldm_eki_data"
    • 크기: 가변 (헤더 + 관측값 배열)
    • 예시 크기: 13,836 bytes (16 receptors × 216 timesteps)

[10] 데이터 헤더 초기화
    • status = 0: 아직 데이터 쓰는 중 (Python이 읽으면 안 됨)
    • rows = num_receptors: 16
    • cols = num_timesteps: 216
    • 실제 관측값은 writeObservations()에서 작성

[11] 초기화 완료
    • initialized = true 설정
    • 콘솔에 설정 요약 출력 (색상 포함)


**에러 처리 패턴:**

모든 시스템 콜 후 에러 확인:
```cpp
if (shm_open(...) < 0) {
    perror("shm_open config");  // errno 기반 에러 메시지
    return false;
}
```

실패 시 이전 리소스 정리:
```cpp
if (mmap(...) == MAP_FAILED) {
    munmap(config_map, sizeof(EKIConfigFull));  // 이미 매핑된 것 해제
    close(config_fd);                           // 파일 디스크립터 닫기
    return false;
}
```

**출력 예시:**

```
[IPC] Writer initialized with full configuration
  Ensembles      : 100
  Receptors      : 16
  Timesteps      : 216
  Iteration      : 10
  Regularization : On
```


2.3 초기 관측값 전송
────────────────────────────────────────────────────────────────────────────

writeObservations() 메서드는 참값 시뮬레이션 후 수집한 관측값을 Python으로
전송합니다.

**함수 시그니처:**

```cpp
bool EKIWriter::writeObservations(const float* observations,
                                  int rows,
                                  int cols);
```

**매개변수:**
  • observations: 관측값 배열 포인터 (row-major, C-order)
  • rows: 수용체 수 (예: 16)
  • cols: 타임스텝 수 (예: 216)

**데이터 레이아웃 (row-major):**

```
observations[0]    = receptor_0, time_0
observations[1]    = receptor_0, time_1
observations[2]    = receptor_0, time_2
...
observations[215]  = receptor_0, time_215
observations[216]  = receptor_1, time_0
observations[217]  = receptor_1, time_1
...
observations[3455] = receptor_15, time_215

총 요소 수: 16 × 216 = 3,456 floats = 13,824 bytes
```

**구현 코드:**

```cpp
// src/ipc/ldm_eki_writer.cu

bool EKIWriter::writeObservations(const float* observations,
                                  int rows,
                                  int cols) {
    // [1] 초기화 확인
    if (!initialized) {
        std::cerr << "EKIWriter not initialized" << std::endl;
        return false;
    }

    // [2] 헤더 포인터 가져오기
    auto* header = reinterpret_cast<EKIDataHeader*>(data_map);

    // [3] 차원 검증
    if (rows != header->rows || cols != header->cols) {
        std::cerr << "Dimension mismatch: expected "
                  << header->rows << "x" << header->cols
                  << ", got " << rows << "x" << cols << std::endl;
        return false;
    }

    // [4] 쓰기 시작 신호 (status = 0)
    header->status = 0;

    // [5] 데이터 포인터 계산
    float* data_ptr = reinterpret_cast<float*>(
        reinterpret_cast<uint8_t*>(data_map) + sizeof(EKIDataHeader)
    );

    // [6] 관측값 복사
    memcpy(data_ptr, observations, rows * cols * sizeof(float));

    // [7] Memory Doctor 로깅 (활성화 시)
    if (g_memory_doctor.isEnabled()) {
        g_memory_doctor.logSentData("initial_observations",
                                   observations, rows, cols, 0,
                                   "LDM->Python initial EKI observations");
    }

    // [8] 쓰기 완료 신호 (status = 1)
    header->status = 1;

    // [9] 전송 완료 메시지
    std::cout << Color::CYAN << "[IPC] " << Color::RESET
              << "Observations written: " << Color::BOLD
              << rows << "×" << cols << Color::RESET
              << " matrix (" << (rows * cols * sizeof(float)) / 1024.0
              << " KB)\n";
    return true;
}
```

**단계별 설명:**

[1] 초기화 확인
    • initialized 플래그 확인
    • initialize()를 먼저 호출하지 않으면 에러

[2] 헤더 포인터 가져오기
    • data_map을 EKIDataHeader*로 캐스팅
    • 메모리 레이아웃:
      [0-11 bytes]: EKIDataHeader
      [12+ bytes]: float 배열

[3] 차원 검증
    • 전달된 rows, cols가 헤더의 값과 일치하는지 확인
    • 불일치 시 오류 메시지 출력 후 false 반환
    • 버퍼 오버플로우 방지

[4] 쓰기 시작 신호
    • header->status = 0
    • Python이 읽는 중이면 status=0이므로 대기
    • 데이터 일관성 보장

[5] 데이터 포인터 계산
    • data_map + sizeof(EKIDataHeader) = 데이터 시작 주소
    • uint8_t*로 캐스팅하여 바이트 단위 포인터 연산
    • float*로 재캐스팅

[6] 관측값 복사
    • memcpy(): 고속 메모리 복사
    • 크기: rows × cols × sizeof(float) bytes
    • 예시: 16 × 216 × 4 = 13,824 bytes
    • 전송 시간: ~0.1 ms (DRAM 대역폭 100 GB/s 기준)

[7] Memory Doctor 로깅
    • 디버그 모드에서 전송 데이터 기록
    • /tmp/eki_debug/initial_observations.npz 저장
    • iteration = 0 (초기 관측값)

[8] 쓰기 완료 신호
    • header->status = 1
    • Python이 이제 안전하게 읽을 수 있음
    • 단순 플래그 기반 동기화

[9] 전송 완료 메시지
    • 콘솔에 전송 정보 출력
    • 색상 코딩 ([IPC] 태그는 CYAN)


**핸드셰이크 프로토콜:**

```
시간    C++                     공유 메모리         Python
─────────────────────────────────────────────────────────────
t0      header->status = 0      status = 0         (대기)
        (데이터 쓰기 시작)

t1      memcpy(data, obs, ...)  status = 0         (대기)
        (데이터 복사 중)        data = [...]

t2      header->status = 1      status = 1         status 확인
        (쓰기 완료)             data = [완전]      → status==1

t3      (완료)                  status = 1         data 읽기
                                                   → 복사 완료

t4                              status = 1         (완료)
```

**출력 예시:**

```
[IPC] Observations written: 16×216 matrix (13.50 KB)
```


2.4 앙상블 관측값 전송
────────────────────────────────────────────────────────────────────────────

앙상블 관측값은 반복 루프에서 매번 전송되는 핵심 데이터입니다.
각 앙상블 멤버별 관측값을 3D 텐서로 전송합니다.

**2.4.1 앙상블 관측값 초기화**

첫 번째 반복 전에 한 번만 호출하여 설정 정보를 전송합니다.

```cpp
bool EKIWriter::initializeEnsembleObservations(int ensemble_size,
                                               int num_receptors,
                                               int num_timesteps);
```

**구현 코드:**

```cpp
// src/ipc/ldm_eki_writer.cu

bool EKIWriter::initializeEnsembleObservations(int ensemble_size,
                                               int num_receptors,
                                               int num_timesteps) {
    if (!initialized) {
        std::cerr << "EKIWriter not initialized. Call initialize() first."
                  << std::endl;
        return false;
    }

    // [1] 앙상블 관측값 설정 공유 메모리 생성
    int ens_obs_config_fd = shm_open(SHM_ENSEMBLE_OBS_CONFIG_NAME,
                                     O_CREAT | O_RDWR | O_TRUNC, 0666);
    if (ens_obs_config_fd < 0) {
        std::cerr << "Failed to create ensemble obs config shared memory: "
                  << strerror(errno) << std::endl;
        return false;
    }

    // [2] 크기 설정 (12 바이트)
    if (ftruncate(ens_obs_config_fd, sizeof(EKIConfigBasic)) != 0) {
        std::cerr << "Failed to set ensemble obs config size: "
                  << strerror(errno) << std::endl;
        close(ens_obs_config_fd);
        return false;
    }

    // [3] 메모리 매핑
    void* ens_obs_config_map = mmap(nullptr, sizeof(EKIConfigBasic),
                                   PROT_READ | PROT_WRITE,
                                   MAP_SHARED, ens_obs_config_fd, 0);
    if (ens_obs_config_map == MAP_FAILED) {
        std::cerr << "Failed to map ensemble obs config memory: "
                  << strerror(errno) << std::endl;
        close(ens_obs_config_fd);
        return false;
    }

    // [4] 설정 구조체 작성
    EKIConfigBasic* ens_obs_config =
        static_cast<EKIConfigBasic*>(ens_obs_config_map);
    ens_obs_config->ensemble_size = ensemble_size;
    ens_obs_config->num_receptors = num_receptors;
    ens_obs_config->num_timesteps = num_timesteps;

    // [5] 정리 (데이터는 별도로 전송)
    munmap(ens_obs_config_map, sizeof(EKIConfigBasic));
    close(ens_obs_config_fd);

    // [6] 완료 메시지
    std::cout << Color::CYAN << "[IPC] " << Color::RESET
              << "Ensemble observation config: "
              << Color::BOLD << ensemble_size << Color::RESET
              << " ensembles, "
              << Color::BOLD << num_receptors << Color::RESET
              << " receptors, "
              << Color::BOLD << num_timesteps << Color::RESET
              << " timesteps\n";

    return true;
}
```

생성 파일:
  • /dev/shm/ldm_eki_ensemble_obs_config (12 bytes)

구조체 내용 (EKIConfigBasic):
  • ensemble_size: 100
  • num_receptors: 16
  • num_timesteps: 216


**2.4.2 앙상블 관측값 쓰기**

매 반복마다 호출하여 모든 앙상블 멤버의 관측값을 전송합니다.

```cpp
bool EKIWriter::writeEnsembleObservations(const float* observations,
                                          int ensemble_size,
                                          int num_receptors,
                                          int num_timesteps,
                                          int iteration = -1);
```

**데이터 레이아웃 (3D 텐서, row-major):**

```
observations[0]      = ens_0, receptor_0, time_0
observations[1]      = ens_0, receptor_0, time_1
...
observations[215]    = ens_0, receptor_0, time_215
observations[216]    = ens_0, receptor_1, time_0
...
observations[3455]   = ens_0, receptor_15, time_215
observations[3456]   = ens_1, receptor_0, time_0
...
observations[345599] = ens_99, receptor_15, time_215

총 요소 수: 100 × 16 × 216 = 345,600 floats = 1,382,400 bytes (1.32 MB)
```

**구현 코드:**

```cpp
// src/ipc/ldm_eki_writer.cu

bool EKIWriter::writeEnsembleObservations(const float* observations,
                                          int ensemble_size,
                                          int num_receptors,
                                          int num_timesteps,
                                          int iteration) {
    if (!initialized) {
        std::cerr << "EKIWriter not initialized" << std::endl;
        return false;
    }

    // [1] 데이터 크기 계산
    size_t ens_obs_data_size = ensemble_size * num_receptors *
                               num_timesteps * sizeof(float);

    // [2] 데이터 공유 메모리 생성/초기화
    int ens_obs_data_fd = shm_open(SHM_ENSEMBLE_OBS_DATA_NAME,
                                   O_CREAT | O_RDWR | O_TRUNC, 0666);
    if (ens_obs_data_fd < 0) {
        std::cerr << "Failed to create ensemble obs data shared memory: "
                  << strerror(errno) << std::endl;
        return false;
    }

    // [3] 데이터 크기 설정
    if (ftruncate(ens_obs_data_fd, ens_obs_data_size) != 0) {
        std::cerr << "Failed to set ensemble obs data size: "
                  << strerror(errno) << std::endl;
        close(ens_obs_data_fd);
        return false;
    }

    // [4] 메모리 매핑
    void* ens_obs_data_map = mmap(nullptr, ens_obs_data_size,
                                 PROT_READ | PROT_WRITE,
                                 MAP_SHARED, ens_obs_data_fd, 0);
    if (ens_obs_data_map == MAP_FAILED) {
        std::cerr << "Failed to map ensemble obs data memory: "
                  << strerror(errno) << std::endl;
        close(ens_obs_data_fd);
        return false;
    }

    // [5] 데이터 복사
    memcpy(ens_obs_data_map, observations, ens_obs_data_size);

    // [6] 통계 계산 (검증용)
    float min_val = observations[0];
    float max_val = observations[0];
    float sum_val = 0.0f;
    int total_elements = ensemble_size * num_receptors * num_timesteps;

    for (int i = 0; i < total_elements; i++) {
        float val = observations[i];
        if (val < min_val) min_val = val;
        if (val > max_val) max_val = val;
        sum_val += val;
    }

    // [7] 전송 완료 메시지
    std::cout << Color::CYAN << "[IPC] " << Color::RESET
              << "Ensemble observations written (" << Color::BOLD
              << ens_obs_data_size / 1024.0 << " KB" << Color::RESET << ")\n";
    std::cout << "  Shape : [" << ensemble_size << " × "
              << num_receptors << " × " << num_timesteps << "]\n";
    std::cout << "  Range : [" << min_val << ", " << max_val
              << "], mean=" << (sum_val / total_elements) << "\n";

    // [8] Memory Doctor 로깅
    if (g_memory_doctor.isEnabled()) {
        std::string info = "EKI iteration " + std::to_string(iteration) +
                          ": " + std::to_string(ensemble_size) + " ensembles";
        g_memory_doctor.logSentData("ensemble_observations", observations,
                                   ensemble_size * num_receptors,
                                   num_timesteps, iteration, info);
    }

    // [9] 정리
    munmap(ens_obs_data_map, ens_obs_data_size);
    close(ens_obs_data_fd);

    return true;
}
```

**특징:**

[1] 매 반복마다 새로 생성
    • O_TRUNC 플래그: 기존 파일 내용 삭제
    • 이전 반복 데이터 자동 제거
    • Python이 읽기 전에 새 데이터 보장

[2] 대용량 데이터 전송
    • 일반적 크기: 1~2 MB
    • memcpy() 전송 시간: ~1~2 ms
    • 네트워크 대비 100배 이상 빠름

[3] 통계 계산
    • min, max, mean 계산
    • 데이터 유효성 검증
    • NaN, Inf 감지 가능

[4] Memory Doctor 통합
    • 디버그 모드에서 데이터 덤프
    • iteration 번호로 파일 구분
    • /tmp/eki_debug/ensemble_observations_iter_N.npz

**출력 예시:**

```
[IPC] Ensemble observations written (1350.00 KB)
  Shape : [100 × 16 × 216]
  Range : [0.000000e+00, 3.456789e-08], mean=1.234567e-09
```


2.5 참값 방출량 전송
────────────────────────────────────────────────────────────────────────────

v1.0에서 추가된 기능으로, 참값 방출량 시계열을 C++에서 Python으로 전송합니다.
이전에는 Python에 하드코딩되어 있었으나, 이제 eki.conf에서 읽어 전송합니다.

**함수 시그니처:**

```cpp
bool EKIWriter::writeTrueEmissions(const std::vector<float>& emissions);
```

**매개변수:**
  • emissions: 참값 방출량 시계열 (g_eki.true_emissions에서 전달)

**구현 코드:**

```cpp
// src/ipc/ldm_eki_writer.cu

bool EKIWriter::writeTrueEmissions(const std::vector<float>& emissions) {
    if (!initialized) {
        std::cerr << "EKIWriter not initialized" << std::endl;
        return false;
    }

    if (emissions.empty()) {
        std::cerr << "Cannot write empty true emissions array" << std::endl;
        return false;
    }

    // [1] 데이터 크기 계산
    size_t emissions_size = emissions.size() * sizeof(float);

    // [2] 공유 메모리 생성
    int emissions_fd = shm_open(SHM_TRUE_EMISSIONS_NAME,
                               O_CREAT | O_RDWR | O_TRUNC, 0666);
    if (emissions_fd < 0) {
        std::cerr << "Failed to create true emissions shared memory: "
                  << strerror(errno) << std::endl;
        return false;
    }

    // [3] 크기 설정
    if (ftruncate(emissions_fd, emissions_size) != 0) {
        std::cerr << "Failed to set true emissions data size: "
                  << strerror(errno) << std::endl;
        close(emissions_fd);
        return false;
    }

    // [4] 메모리 매핑
    void* emissions_map = mmap(nullptr, emissions_size,
                              PROT_READ | PROT_WRITE,
                              MAP_SHARED, emissions_fd, 0);
    if (emissions_map == MAP_FAILED) {
        std::cerr << "Failed to map true emissions memory: "
                  << strerror(errno) << std::endl;
        close(emissions_fd);
        return false;
    }

    // [5] 데이터 복사
    memcpy(emissions_map, emissions.data(), emissions_size);

    // [6] 통계 계산
    float min_val = emissions[0];
    float max_val = emissions[0];
    float sum_val = 0.0f;

    for (size_t i = 0; i < emissions.size(); i++) {
        float val = emissions[i];
        if (val < min_val) min_val = val;
        if (val > max_val) max_val = val;
        sum_val += val;
    }

    // [7] 전송 완료 메시지
    std::cout << Color::CYAN << "[IPC] " << Color::RESET
              << "True emissions written (" << Color::BOLD
              << emissions_size / 1024.0 << " KB" << Color::RESET << ")\n";
    std::cout << "  Length : " << emissions.size() << " timesteps\n";
    std::cout << "  Range  : [" << min_val << ", " << max_val
              << "], sum=" << sum_val << "\n";

    // [8] Memory Doctor 로깅
    if (g_memory_doctor.isEnabled()) {
        g_memory_doctor.logSentData("true_emissions", emissions.data(),
                                   1, emissions.size(), 0,
                                   "True emission time series from eki.conf");
    }

    // [9] 정리
    munmap(emissions_map, emissions_size);
    close(emissions_fd);

    return true;
}
```

생성 파일:
  • /dev/shm/ldm_eki_true_emissions (num_timesteps × 4 bytes)

예시 데이터 (24 timesteps):
```
[1.0e+12, 1.0e+12, 1.0e+12, ..., 1.0e+12]  (constant emission)
또는
[0, 0, 1.0e+13, 5.0e+12, 2.0e+12, ...]     (variable emission)
```

**출력 예시:**

```
[IPC] True emissions written (0.09 KB)
  Length : 24 timesteps
  Range  : [1.000000e+12, 1.000000e+12], sum=2.400000e+13
```


2.6 정리 및 메모리 해제
────────────────────────────────────────────────────────────────────────────

**2.6.1 cleanup() 메서드**

리소스를 해제하지만 공유 메모리 파일은 삭제하지 않습니다 (Python이 읽어야 함).

```cpp
void EKIWriter::cleanup() {
    // [1] 데이터 메모리 매핑 해제
    if (data_map) {
        munmap(data_map, data_size);
        data_map = nullptr;
    }

    // [2] 설정 메모리 매핑 해제
    if (config_map) {
        munmap(config_map, sizeof(EKIConfigFull));
        config_map = nullptr;
    }

    // [3] 데이터 파일 디스크립터 닫기
    if (data_fd >= 0) {
        close(data_fd);
        data_fd = -1;
    }

    // [4] 설정 파일 디스크립터 닫기
    if (config_fd >= 0) {
        close(config_fd);
        config_fd = -1;
    }

    // [5] 초기화 플래그 재설정
    initialized = false;
}
```

특징:
  • 안전한 포인터 확인 (nullptr/유효성 검사)
  • 역순 정리 (데이터 → 설정, 후입선출)
  • 공유 메모리 파일 유지 (shm_unlink() 호출 안 함)
  • 소멸자에서 자동 호출


**2.6.2 unlinkSharedMemory() 정적 메서드**

프로그램 종료 시 공유 메모리 파일을 파일시스템에서 삭제합니다.

```cpp
void EKIWriter::unlinkSharedMemory() {
    shm_unlink(SHM_CONFIG_NAME);
    shm_unlink(SHM_DATA_NAME);
    // 주의: 앙상블 관측값 파일은 삭제하지 않음 (Python이 필요)
    // shm_unlink(SHM_ENSEMBLE_OBS_CONFIG_NAME);
    // shm_unlink(SHM_ENSEMBLE_OBS_DATA_NAME);
    std::cout << Color::CYAN << "[IPC] " << Color::RESET
              << "Shared memory unlinked (ensemble obs kept for Python)\n";
}
```

호출 시점:
  • main_eki.cu의 프로그램 종료 직전
  • Python 프로세스가 모든 데이터 읽은 후

삭제 파일:
  • /dev/shm/ldm_eki_config
  • /dev/shm/ldm_eki_data

유지 파일 (Python이 읽어야 함):
  • /dev/shm/ldm_eki_ensemble_obs_config
  • /dev/shm/ldm_eki_ensemble_obs_data


**2.6.3 getConfig() 메서드**

현재 설정된 차원 정보를 조회합니다 (디버그/검증용).

```cpp
bool EKIWriter::getConfig(int& ensemble_size,
                          int& num_receptors,
                          int& num_timesteps) {
    if (!initialized) {
        return false;
    }

    auto* config = reinterpret_cast<EKIConfigFull*>(config_map);
    ensemble_size = config->ensemble_size;
    num_receptors = config->num_receptors;
    num_timesteps = config->num_timesteps;
    return true;
}
```

사용 예시:
```cpp
int ens, rec, ts;
if (writer.getConfig(ens, rec, ts)) {
    std::cout << "Config: " << ens << " ensembles, "
              << rec << " receptors, "
              << ts << " timesteps\n";
}
```


================================================================================
3. 데이터 구조체
================================================================================

3.1 EKIConfigFull 구조체 (84 바이트)
────────────────────────────────────────────────────────────────────────────

**정의 위치:** src/ipc/ldm_eki_writer.cuh

**구조체 정의:**

```cpp
struct EKIConfigFull {
    // 기본 차원 정보 (12 bytes)
    int32_t ensemble_size;     // 앙상블 멤버 수 (예: 100)
    int32_t num_receptors;     // 수용체 개수 (예: 16)
    int32_t num_timesteps;     // 타임스텝 수 (예: 216)

    // 알고리즘 파라미터 (24 bytes)
    int32_t iteration;         // 최대 EKI 반복 횟수 (예: 10)
    float renkf_lambda;        // REnKF 정규화 파라미터 (예: 0.1)
    float noise_level;         // 관측 노이즈 레벨 (예: 0.05)
    float time_interval;       // EKI 시간 간격 [초] (예: 100.0)
    float prior_constant;      // 사전 방출량 상수 [Bq] (예: 1.0e+13)
    float decay_constant;      // 핵종 붕괴 상수 λ [s⁻¹] (예: 6.78e-5)

    // 옵션 문자열 (40 bytes = 5 × 8 bytes)
    char perturb_option[8];    // 섭동 옵션: "On"/"Off"
    char adaptive_eki[8];      // 적응형 EKI: "On"/"Off"
    char localized_eki[8];     // 국소화 EKI: "Off" (v1.0 강제)
    char regularization[8];    // 정규화: "On"/"Off"
    char time_unit[8];         // 시간 단위: "seconds"/"minutes"/"hours"

    // Memory Doctor 모드 (8 bytes)
    char memory_doctor[8];     // 디버그 모드: "On"/"Off"

    // 총합: 12 + 24 + 40 + 8 = 84 bytes (패딩 없음)
};
```

**메모리 레이아웃 (바이트 오프셋):**

```
Offset  Size  Field Name        Type     Example Value
─────────────────────────────────────────────────────────────
0       4     ensemble_size     int32    100
4       4     num_receptors     int32    16
8       4     num_timesteps     int32    216

12      4     iteration         int32    10
16      4     renkf_lambda      float    0.1
20      4     noise_level       float    0.05
24      4     time_interval     float    100.0
28      4     prior_constant    float    1.0e+13
32      4     decay_constant    float    6.78e-5

36      8     perturb_option    char[8]  "On\0\0\0\0\0\0"
44      8     adaptive_eki      char[8]  "Off\0\0\0\0\0"
52      8     localized_eki     char[8]  "Off\0\0\0\0\0"
60      8     regularization    char[8]  "On\0\0\0\0\0\0"
68      8     time_unit         char[8]  "seconds"

76      8     memory_doctor     char[8]  "Off\0\0\0\0\0"
─────────────────────────────────────────────────────────────
Total: 84 bytes
```

**C++ 패킹 (리틀 엔디안, x86-64):**

```cpp
// C++에서 메모리에 쓰기
EKIConfigFull config;
memset(&config, 0, sizeof(config));
config.ensemble_size = 100;
config.num_receptors = 16;
// ...
memcpy(shm_ptr, &config, sizeof(config));
```

**Python 언패킹:**

```python
# Python에서 메모리 읽기
import struct

with open("/dev/shm/ldm_eki_config", 'rb') as f:
    data = f.read(84)

# 기본 정보
ensemble_size, num_receptors, num_timesteps = struct.unpack_from('<3i', data, 0)

# 알고리즘 파라미터
offset = 12
iteration, = struct.unpack_from('<i', data, offset)
offset += 4
renkf_lambda, noise_level, time_interval, prior_constant, decay_constant = struct.unpack_from('<5f', data, offset)
offset += 20  # Now at 36

# 옵션 문자열
perturb_option = data[36:44].decode('utf-8').rstrip('\x00')
adaptive_eki = data[44:52].decode('utf-8').rstrip('\x00')
localized_eki = data[52:60].decode('utf-8').rstrip('\x00')
regularization = data[60:68].decode('utf-8').rstrip('\x00')
time_unit = data[68:76].decode('utf-8').rstrip('\x00')

# Memory Doctor
memory_doctor = data[76:84].decode('utf-8').rstrip('\x00')
```

**hexdump 예시:**

```bash
$ hexdump -C /dev/shm/ldm_eki_config | head -10
00000000  64 00 00 00 10 00 00 00  d8 00 00 00 0a 00 00 00  |d...............|
          ^^ensemble  ^^receptors  ^^timesteps  ^^iteration

00000010  cd cc cc 3d cd cc cc 3d  00 00 c8 42 00 00 28 52  |...=...=...B..(R|
          ^^lambda    ^^noise      ^^interval   ^^prior(상위)

00000020  00 00 60 41 4f 6e 00 00  00 00 00 00 4f 66 66 00  |..`AOn......Off.|
          ^^decay     ^^perturb_option            ^^adaptive

00000030  00 00 00 00 4f 66 66 00  00 00 00 00 4f 6e 00 00  |....Off.....On..|
                      ^^localized                 ^^regulariz

00000040  00 00 00 00 73 65 63 6f  6e 64 73 00 4f 66 66 00  |....seconds.Off.|
                      ^^time_unit                 ^^mem_doctor

00000050  00 00 00 00                                       |....|
```


3.2 EKIConfigBasic 구조체 (12 바이트)
────────────────────────────────────────────────────────────────────────────

**정의 위치:** src/ipc/ldm_eki_writer.cuh

앙상블 관측값 차원 정보만 담은 경량 구조체입니다.

**구조체 정의:**

```cpp
struct EKIConfigBasic {
    int32_t ensemble_size;  // 앙상블 멤버 수 (예: 100)
    int32_t num_receptors;  // 수용체 개수 (예: 16)
    int32_t num_timesteps;  // 타임스텝 수 (예: 216)
};
```

**메모리 레이아웃:**

```
Offset  Size  Field Name        Type     Example Value
─────────────────────────────────────────────────────────────
0       4     ensemble_size     int32    100
4       4     num_receptors     int32    16
8       4     num_timesteps     int32    216
─────────────────────────────────────────────────────────────
Total: 12 bytes
```

**사용처:**
  • /dev/shm/ldm_eki_ensemble_obs_config
  • 앙상블 관측값 3D 텐서 차원 정보

**Python 읽기:**

```python
import struct

with open("/dev/shm/ldm_eki_ensemble_obs_config", 'rb') as f:
    data = f.read(12)
    ensemble_size, num_receptors, num_timesteps = struct.unpack('<3i', data)
```


3.3 EKIDataHeader 구조체
────────────────────────────────────────────────────────────────────────────

**정의 위치:** src/ipc/ldm_eki_writer.cuh

초기 관측값 데이터 헤더입니다.

**구조체 정의:**

```cpp
struct EKIDataHeader {
    int32_t status;      // 0=쓰는 중, 1=완료 (읽기 가능)
    int32_t rows;        // 수용체 개수 (예: 16)
    int32_t cols;        // 타임스텝 수 (예: 216)
    // float data[] follows immediately after header
};
```

**메모리 레이아웃:**

```
Offset  Size  Field Name        Type     Example Value
─────────────────────────────────────────────────────────────
0       4     status            int32    1 (ready)
4       4     rows              int32    16
8       4     cols              int32    216
12      ...   data              float[]  [obs값들...]
─────────────────────────────────────────────────────────────
Total: 12 + (rows × cols × 4) bytes
```

**상태 값:**
  • status = 0: C++가 쓰는 중, Python은 대기해야 함
  • status = 1: 쓰기 완료, Python이 읽을 수 있음

**전체 파일 크기 예시:**
  • rows = 16, cols = 216
  • 헤더: 12 bytes
  • 데이터: 16 × 216 × 4 = 13,824 bytes
  • 총합: 13,836 bytes


3.4 EnsembleConfig 구조체
────────────────────────────────────────────────────────────────────────────

**정의 위치:** src/ipc/ldm_eki_reader.cuh

Python에서 C++로 전송하는 앙상블 상태 설정 정보입니다.

**구조체 정의:**

```cpp
struct EnsembleConfig {
    int32_t num_states;      // 상태 변수 개수 (예: 24 타임스텝)
    int32_t num_ensemble;    // 앙상블 멤버 수 (예: 100)
    int32_t timestep_id;     // 반복 번호 (신선도 감지용)
};
```

**메모리 레이아웃:**

```
Offset  Size  Field Name        Type     Example Value
─────────────────────────────────────────────────────────────
0       4     num_states        int32    24
4       4     num_ensemble      int32    100
8       4     timestep_id       int32    3 (반복 3)
─────────────────────────────────────────────────────────────
Total: 12 bytes
```

**사용처:**
  • /dev/shm/ldm_eki_ensemble_config
  • Python → C++ 앙상블 상태 전송 시


3.5 EnsembleDataHeader 구조체
────────────────────────────────────────────────────────────────────────────

**정의 위치:** src/ipc/ldm_eki_reader.cuh

앙상블 상태 데이터 헤더입니다.

**구조체 정의:**

```cpp
struct EnsembleDataHeader {
    int32_t status;          // 0=쓰는 중, 1=완료
    int32_t rows;            // 상태 변수 개수
    int32_t cols;            // 앙상블 멤버 수
    // float data[] follows immediately after header
};
```

**메모리 레이아웃:**

```
Offset  Size  Field Name        Type     Example Value
─────────────────────────────────────────────────────────────
0       4     status            int32    1
4       4     rows              int32    24
8       4     cols              int32    100
12      ...   data              float[]  [상태 벡터들...]
─────────────────────────────────────────────────────────────
Total: 12 + (rows × cols × 4) bytes
```


3.6 메모리 레이아웃 및 패딩
────────────────────────────────────────────────────────────────────────────

**3.6.1 구조체 정렬 (Alignment)**

모든 구조체는 기본 정렬 규칙을 따릅니다:
  • int32_t: 4 바이트 정렬
  • float: 4 바이트 정렬
  • char[8]: 1 바이트 정렬 (하지만 8의 배수로 배치)

컴파일러 기본 설정:
  • GCC/Clang: -fpack-struct=0 (기본 정렬)
  • #pragma pack 사용 안 함

**3.6.2 패딩 분석**

EKIConfigFull 구조체 (84 바이트):

```
필드                타입      크기  오프셋  정렬  패딩
─────────────────────────────────────────────────────
ensemble_size       int32_t   4     0       4     -
num_receptors       int32_t   4     4       4     -
num_timesteps       int32_t   4     8       4     -
iteration           int32_t   4     12      4     -
renkf_lambda        float     4     16      4     -
noise_level         float     4     20      4     -
time_interval       float     4     24      4     -
prior_constant      float     4     28      4     -
decay_constant      float     4     32      4     -
perturb_option      char[8]   8     36      1     -
adaptive_eki        char[8]   8     44      1     -
localized_eki       char[8]   8     52      1     -
regularization      char[8]   8     60      1     -
time_unit           char[8]   8     68      1     -
memory_doctor       char[8]   8     76      1     -
─────────────────────────────────────────────────────
총 크기: 84 바이트 (패딩 0 바이트)
```

패딩이 없는 이유:
  • 모든 필드가 자연 정렬 경계에 배치
  • int32_t/float: 4의 배수 오프셋
  • char[8]: 8의 배수 오프셋 (우연히)
  • 총 크기가 4의 배수 (84 = 21 × 4)

**3.6.3 엔디언 (Endianness)**

LDM-EKI는 리틀 엔디언 시스템을 가정합니다 (x86-64, ARM64).

예시: int32_t value = 100 (0x00000064)

메모리 레이아웃 (리틀 엔디언):
```
주소    바이트값
0x00    0x64
0x01    0x00
0x02    0x00
0x03    0x00
```

Python struct 모듈:
```python
struct.unpack('<i', data)  # < = 리틀 엔디언
```

**3.6.4 공유 메모리 파일 크기 요약**

┌─────────────────────────────────────┬──────────────┬─────────────────┐
│ 파일명                              │ 크기         │ 내용            │
├─────────────────────────────────────┼──────────────┼─────────────────┤
│ /dev/shm/ldm_eki_config             │ 84 B         │ EKIConfigFull   │
│ /dev/shm/ldm_eki_data               │ ~13.5 KB     │ 초기 관측값     │
│ /dev/shm/ldm_eki_ensemble_obs_config│ 12 B         │ EKIConfigBasic  │
│ /dev/shm/ldm_eki_ensemble_obs_data  │ ~1.3 MB      │ 앙상블 관측값   │
│ /dev/shm/ldm_eki_true_emissions     │ ~96 B        │ 참값 방출량     │
│ /dev/shm/ldm_eki_ensemble_config    │ 12 B         │ EnsembleConfig  │
│ /dev/shm/ldm_eki_ensemble_data      │ ~9.6 KB      │ 앙상블 상태     │
└─────────────────────────────────────┴──────────────┴─────────────────┘

예시 파라미터 기준:
  • ensembles: 100
  • receptors: 16
  • timesteps: 216 (LDM) / 24 (EKI states)


================================================================================
Part 1 완료
================================================================================

Part 1에서는 다음 내용을 다루었습니다:

✓ 1. 개요 및 아키텍처
  - IPC의 필요성과 역할
  - POSIX 공유 메모리 선택 이유 및 대안 비교
  - 2-프로세스 설계 철학 및 실행 흐름

✓ 2. C++ IPC Writer 구현
  - EKIWriter 클래스 전체 구조
  - 초기화 메서드 (initialize)
  - 초기 관측값 전송 (writeObservations)
  - 앙상블 관측값 전송 (initializeEnsembleObservations, writeEnsembleObservations)
  - 참값 방출량 전송 (writeTrueEmissions)
  - 정리 및 메모리 해제 (cleanup, unlinkSharedMemory)

✓ 3. 데이터 구조체
  - EKIConfigFull 구조체 (84 바이트) - 전체 설정
  - EKIConfigBasic 구조체 (12 바이트) - 앙상블 차원
  - EKIDataHeader 구조체 - 관측값 헤더
  - EnsembleConfig 구조체 - 앙상블 상태 설정
  - EnsembleDataHeader 구조체 - 앙상블 데이터 헤더
  - 메모리 레이아웃, 패딩, 엔디언 분석


Part 2 예고:
  • Python IPC 구현 (Reader, Writer, Config)
  • C++ EKIReader 클래스
  • 통신 프로토콜 및 시퀀스 다이어그램
  • Row-major vs Column-major 변환

Part 3 예고:
  • 동기화 메커니즘 (polling, 타임아웃)
  • 에러 처리 및 복구 전략
  • Memory Doctor 통합
  • 성능 분석 및 최적화

총 라인 수: 1,207줄

================================================================================
End of Part 1
================================================================================
